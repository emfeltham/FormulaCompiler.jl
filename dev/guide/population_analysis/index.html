<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Population Analysis Using Row-Wise Functions · FormulaCompiler.jl</title><meta name="title" content="Population Analysis Using Row-Wise Functions · FormulaCompiler.jl"/><meta property="og:title" content="Population Analysis Using Row-Wise Functions · FormulaCompiler.jl"/><meta property="twitter:title" content="Population Analysis Using Row-Wise Functions · FormulaCompiler.jl"/><meta name="description" content="Documentation for FormulaCompiler.jl."/><meta property="og:description" content="Documentation for FormulaCompiler.jl."/><meta property="twitter:description" content="Documentation for FormulaCompiler.jl."/><meta property="og:url" content="https://emfeltham.github.io/FormulaCompiler.jl/guide/population_analysis/"/><meta property="twitter:url" content="https://emfeltham.github.io/FormulaCompiler.jl/guide/population_analysis/"/><link rel="canonical" href="https://emfeltham.github.io/FormulaCompiler.jl/guide/population_analysis/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/mermaid.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FormulaCompiler.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../advanced_features/">Advanced Features</a></li><li><a class="tocitem" href="../categorical_mixtures/">Categorical Mixtures</a></li><li><a class="tocitem" href="../scenarios/">Scenario Analysis</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../../integration/glm/">GLM.jl</a></li><li><a class="tocitem" href="../../integration/mixed_models/">MixedModels.jl</a></li><li><a class="tocitem" href="../../integration/standardized_predictors/">StandardizedPredictors.jl</a></li></ul></li><li><a class="tocitem" href="../../mathematical_foundation/">Mathematical Foundation</a></li><li><a class="tocitem" href="../../architecture/">Architecture</a></li><li><a class="tocitem" href="../../metaprogramming/">Metaprogramming</a></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Population Analysis Using Row-Wise Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Population Analysis Using Row-Wise Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/emfeltham/FormulaCompiler.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/main/docs/src/guide/population_analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Population-Analysis-Using-Row-Wise-Functions"><a class="docs-heading-anchor" href="#Population-Analysis-Using-Row-Wise-Functions">Population Analysis Using Row-Wise Functions</a><a id="Population-Analysis-Using-Row-Wise-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Population-Analysis-Using-Row-Wise-Functions" title="Permalink"></a></h1><p>This guide shows how to perform population-level analysis using row-wise marginal effects functions. The key insight is that <strong>population effects are simply averages over individual effects</strong> - simple loops over rows are all you need.</p><blockquote><p><strong>Note</strong>: Marginal effects functions (<code>marginal_effects_eta!</code>, <code>marginal_effects_mu!</code>, etc.) are provided by <a href="https://github.com/emfeltham/Margins.jl">Margins.jl</a>. FormulaCompiler provides the computational primitives (<code>derivative_modelrow!</code>) that Margins.jl builds upon. Install Margins.jl to use the examples in this guide: <code>using Pkg; Pkg.add(url=&quot;https://github.com/emfeltham/Margins.jl&quot;)</code></p></blockquote><h2 id="Core-Principle"><a class="docs-heading-anchor" href="#Core-Principle">Core Principle</a><a id="Core-Principle-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Principle" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Population Average Marginal Effect (AME)
AME = (1/n) × Σᵢ ∂f(xᵢ)/∂x

# Implementation: Individual effects + averaging
population_effects = Vector{Float64}(undef, n_rows)
for (i, row) in enumerate(rows)
    marginal_effects_eta!(temp_buffer, de, β, row)  # Existing row-wise function
    population_effects[i] = temp_buffer[var_index]
end
population_ame = mean(population_effects)  # Simple arithmetic</code></pre><h2 id="Computing-Population-Marginal-Effects"><a class="docs-heading-anchor" href="#Computing-Population-Marginal-Effects">Computing Population Marginal Effects</a><a id="Computing-Population-Marginal-Effects-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Population-Marginal-Effects" title="Permalink"></a></h2><h3 id="Basic-Pattern"><a class="docs-heading-anchor" href="#Basic-Pattern">Basic Pattern</a><a id="Basic-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Pattern" title="Permalink"></a></h3><p>Use <code>marginal_effects_eta!()</code> in a loop to compute Average Marginal Effects (AME):</p><pre><code class="language-julia hljs">using FormulaCompiler, Margins, GLM, DataFrames, Tables

# Setup: Fit model and compile
df = DataFrame(
    y = randn(1000),
    x = randn(1000),
    age = rand(18:80, 1000),
    income = exp.(randn(1000))
)
model = lm(@formula(y ~ x + age + log(income)), df)
data = Tables.columntable(df)
compiled = compile_formula(model, data)

# Build derivative evaluator for variables of interest
de = derivativeevaluator(:fd, compiled, data, [:x, :age])
β = coef(model)

# Compute population marginal effects
n_rows = length(df.y)
temp_buffer = Vector{Float64}(undef, length(de.vars))
ame_results = zeros(length(de.vars))

for row in 1:n_rows
    # Compute marginal effects for this individual
    marginal_effects_eta!(temp_buffer, de, β, row)

    # Accumulate for population average
    ame_results .+= temp_buffer
end

# Population AME = average over individuals
ame_results ./= n_rows

println(&quot;Population Average Marginal Effects:&quot;)
for (i, var) in enumerate(de.vars)
    println(&quot;  $var: $(ame_results[i])&quot;)
end</code></pre><h3 id="Weighted-Population-Effects"><a class="docs-heading-anchor" href="#Weighted-Population-Effects">Weighted Population Effects</a><a id="Weighted-Population-Effects-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-Population-Effects" title="Permalink"></a></h3><p>For survey data or other weighted analyses:</p><pre><code class="language-julia hljs"># Assume we have survey weights
weights = rand(0.5:0.1:2.0, n_rows)  # Example weights
total_weight = sum(weights)

# Weighted population marginal effects
weighted_ame = zeros(length(de.vars))

for row in 1:n_rows
    marginal_effects_eta!(temp_buffer, de, β, row)

    # Weight each individual&#39;s contribution
    weighted_ame .+= weights[row] .* temp_buffer
end

# Weighted average
weighted_ame ./= total_weight

println(&quot;Weighted Population AME:&quot;)
for (i, var) in enumerate(de.vars)
    println(&quot;  $var: $(weighted_ame[i])&quot;)
end</code></pre><h2 id="Scenario-Analysis-Using-Data-Modification"><a class="docs-heading-anchor" href="#Scenario-Analysis-Using-Data-Modification">Scenario Analysis Using Data Modification</a><a id="Scenario-Analysis-Using-Data-Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Scenario-Analysis-Using-Data-Modification" title="Permalink"></a></h2><h3 id="Single-Variable-Scenario"><a class="docs-heading-anchor" href="#Single-Variable-Scenario">Single Variable Scenario</a><a id="Single-Variable-Scenario-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Variable-Scenario" title="Permalink"></a></h3><p>Evaluate &quot;what if all individuals had a specific value for a variable&quot;:</p><pre><code class="language-julia hljs"># Scenario: What if everyone had income = 50,000?
scenario_var = :income
scenario_value = log(50000)  # Model uses log(income)

# Create counterfactual data with modified variable
cf_data = merge(data, (income = fill(scenario_value, n_rows),))

# Evaluate scenario for each individual
scenario_predictions = Vector{Float64}(undef, n_rows)
output_buffer = Vector{Float64}(undef, length(compiled))

for row in 1:n_rows
    # Evaluate model with counterfactual data
    compiled(output_buffer, cf_data, row)

    # Extract prediction (assuming single outcome)
    scenario_predictions[row] = dot(β, output_buffer)
end

# Population-level scenario results
population_scenario_mean = mean(scenario_predictions)
println(&quot;Population mean under scenario: $population_scenario_mean&quot;)

# Compare with baseline
baseline_predictions = Vector{Float64}(undef, n_rows)
for row in 1:n_rows
    compiled(output_buffer, data, row)
    baseline_predictions[row] = dot(β, output_buffer)
end

baseline_mean = mean(baseline_predictions)
scenario_effect = population_scenario_mean - baseline_mean
println(&quot;Population scenario effect: $scenario_effect&quot;)</code></pre><h3 id="Multiple-Variable-Scenarios"><a class="docs-heading-anchor" href="#Multiple-Variable-Scenarios">Multiple Variable Scenarios</a><a id="Multiple-Variable-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Variable-Scenarios" title="Permalink"></a></h3><p>Policy analysis with multiple variables changed simultaneously:</p><pre><code class="language-julia hljs"># Policy scenario: Universal basic income + education investment
policy_vars = [:income, :education_years]
policy_values = [log(30000), 16.0]  # $30k income, 16 years education

# Create counterfactual data with multiple modified variables
cf_data = merge(data, (
    income = fill(policy_values[1], n_rows),
    education_years = fill(policy_values[2], n_rows)
))

# Evaluate policy for each individual
policy_predictions = Vector{Float64}(undef, n_rows)

for row in 1:n_rows
    # Evaluate under policy
    compiled(output_buffer, cf_data, row)
    policy_predictions[row] = dot(β, output_buffer)
end

# Policy impact analysis
policy_effect = mean(policy_predictions) - baseline_mean
println(&quot;Policy effect: $policy_effect&quot;)

# Distribution analysis
println(&quot;Policy effect distribution:&quot;)
println(&quot;  Min: $(minimum(policy_predictions - baseline_predictions))&quot;)
println(&quot;  Max: $(maximum(policy_predictions - baseline_predictions))&quot;)
println(&quot;  Std: $(std(policy_predictions - baseline_predictions))&quot;)</code></pre><h2 id="Comparing-Multiple-Scenarios"><a class="docs-heading-anchor" href="#Comparing-Multiple-Scenarios">Comparing Multiple Scenarios</a><a id="Comparing-Multiple-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-Multiple-Scenarios" title="Permalink"></a></h2><p>Systematic policy comparison:</p><pre><code class="language-julia hljs"># Define scenarios to compare
scenarios = [
    (name=&quot;Baseline&quot;, vars=Symbol[], values=Float64[]),
    (name=&quot;Income +20%&quot;, vars=[:income], values=[log(1.2)]),  # Relative increase
    (name=&quot;Education +2yr&quot;, vars=[:education_years], values=[2.0]),  # Absolute increase
    (name=&quot;Combined&quot;, vars=[:income, :education_years], values=[log(1.2), 2.0])
]

scenario_results = Dict{String, Vector{Float64}}()

for scenario in scenarios
    if isempty(scenario.vars)
        # Baseline: use original data
        predictions = Vector{Float64}(undef, n_rows)
        for row in 1:n_rows
            compiled(output_buffer, data, row)
            predictions[row] = dot(β, output_buffer)
        end
        scenario_results[scenario.name] = predictions
    else
        # Counterfactual scenario - build modified data
        # Handle relative vs absolute changes
        modified_cols = Dict{Symbol, Vector{Float64}}()

        for (i, (var, value)) in enumerate(zip(scenario.vars, scenario.values))
            if var == :income  # Relative change
                # Add log(1.2) to each individual&#39;s log(income)
                modified_cols[var] = getproperty(data, var) .+ value
            else  # Absolute change
                # Add fixed value to each individual&#39;s value
                modified_cols[var] = getproperty(data, var) .+ value
            end
        end

        cf_data = merge(data, NamedTuple(modified_cols))

        predictions = Vector{Float64}(undef, n_rows)
        for row in 1:n_rows
            compiled(output_buffer, cf_data, row)
            predictions[row] = dot(β, output_buffer)
        end
        scenario_results[scenario.name] = predictions
    end
end

# Compare scenarios
println(&quot;Scenario Comparison:&quot;)
baseline = scenario_results[&quot;Baseline&quot;]
for (name, predictions) in scenario_results
    if name != &quot;Baseline&quot;
        effect = mean(predictions) - mean(baseline)
        println(&quot;  $name: $(round(effect, digits=4))&quot;)
    end
end</code></pre><h2 id="Performance-Tips-for-Large-Datasets"><a class="docs-heading-anchor" href="#Performance-Tips-for-Large-Datasets">Performance Tips for Large Datasets</a><a id="Performance-Tips-for-Large-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips-for-Large-Datasets" title="Permalink"></a></h2><h3 id="Buffer-Reuse"><a class="docs-heading-anchor" href="#Buffer-Reuse">Buffer Reuse</a><a id="Buffer-Reuse-1"></a><a class="docs-heading-anchor-permalink" href="#Buffer-Reuse" title="Permalink"></a></h3><p>For large datasets, reuse buffers to minimize allocations:</p><pre><code class="language-julia hljs"># Pre-allocate all buffers
n_rows = length(df.y)
n_vars = length(de.vars)
temp_buffer = Vector{Float64}(undef, n_vars)
output_buffer = Vector{Float64}(undef, length(compiled))
ame_accumulator = zeros(n_vars)

# Efficient loop with buffer reuse
for row in 1:n_rows
    # Reuse temp_buffer for each row
    marginal_effects_eta!(temp_buffer, de, β, row)
    ame_accumulator .+= temp_buffer
end

ame_results = ame_accumulator ./ n_rows</code></pre><h3 id="Batch-Processing"><a class="docs-heading-anchor" href="#Batch-Processing">Batch Processing</a><a id="Batch-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Processing" title="Permalink"></a></h3><p>For very large datasets, process in batches:</p><pre><code class="language-julia hljs">function compute_population_ame_batched(de, β, batch_size=1000)
    n_rows = length(getproperty(de.base_data, first(de.vars)))
    n_vars = length(de.vars)

    ame_accumulator = zeros(n_vars)
    temp_buffer = Vector{Float64}(undef, n_vars)

    for batch_start in 1:batch_size:n_rows
        batch_end = min(batch_start + batch_size - 1, n_rows)

        for row in batch_start:batch_end
            marginal_effects_eta!(temp_buffer, de, β, row)
            ame_accumulator .+= temp_buffer
        end

        # Optional: progress reporting
        if batch_end % (10 * batch_size) == 0
            println(&quot;Processed $(batch_end)/$(n_rows) observations&quot;)
        end
    end

    return ame_accumulator ./ n_rows
end

# Usage
ame_results = compute_population_ame_batched(de, β, 5000)</code></pre><h3 id="Parallel-Processing"><a class="docs-heading-anchor" href="#Parallel-Processing">Parallel Processing</a><a id="Parallel-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Processing" title="Permalink"></a></h3><p>For massive datasets, use threading:</p><pre><code class="language-julia hljs">using Base.Threads

function compute_population_ame_parallel(de, β)
    n_rows = length(getproperty(de.base_data, first(de.vars)))
    n_vars = length(de.vars)

    # Thread-local accumulators
    thread_accumulators = [zeros(n_vars) for _ in 1:nthreads()]

    @threads for row in 1:n_rows
        tid = threadid()
        temp_buffer = Vector{Float64}(undef, n_vars)

        marginal_effects_eta!(temp_buffer, de, β, row)
        thread_accumulators[tid] .+= temp_buffer
    end

    # Combine thread results
    total_accumulator = zeros(n_vars)
    for acc in thread_accumulators
        total_accumulator .+= acc
    end

    return total_accumulator ./ n_rows
end

# Usage (requires Julia started with multiple threads)
ame_results = compute_population_ame_parallel(de, β)</code></pre><h2 id="Implementation-Properties"><a class="docs-heading-anchor" href="#Implementation-Properties">Implementation Properties</a><a id="Implementation-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Properties" title="Permalink"></a></h2><h3 id="Memory-Efficiency"><a class="docs-heading-anchor" href="#Memory-Efficiency">Memory Efficiency</a><a id="Memory-Efficiency-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Efficiency" title="Permalink"></a></h3><ul><li><strong>O(1) memory usage</strong>: Independent of dataset size</li><li><strong>No data copying</strong>: CounterfactualVector provides transparent value substitution</li><li><strong>Buffer reuse</strong>: Same temporary arrays used across all rows</li></ul><h3 id="Performance-Characteristics"><a class="docs-heading-anchor" href="#Performance-Characteristics">Performance Characteristics</a><a id="Performance-Characteristics-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Characteristics" title="Permalink"></a></h3><ul><li><strong>Zero allocations</strong>: After warmup, row-wise functions allocate 0 bytes</li><li><strong>Cache efficiency</strong>: Sequential row processing optimizes memory access</li><li><strong>Compiler optimization</strong>: Simple loops enable aggressive optimization</li></ul><h3 id="Simplicity"><a class="docs-heading-anchor" href="#Simplicity">Simplicity</a><a id="Simplicity-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicity" title="Permalink"></a></h3><ul><li><strong>No special API</strong>: Uses existing, well-tested row-wise functions</li><li><strong>Clear semantics</strong>: Population = individual + averaging (mathematically obvious)</li><li><strong>Easy debugging</strong>: Can inspect individual-level results before averaging</li></ul><h3 id="Extensibility"><a class="docs-heading-anchor" href="#Extensibility">Extensibility</a><a id="Extensibility-1"></a><a class="docs-heading-anchor-permalink" href="#Extensibility" title="Permalink"></a></h3><ul><li><strong>Custom aggregation</strong>: Not limited to simple averages (can use quantiles, weighted averages, etc.)</li><li><strong>Conditional analysis</strong>: Easy to subset rows or apply complex filters</li><li><strong>Scenario combinations</strong>: Natural composition of multiple counterfactual changes</li></ul><h2 id="Migration-from-Population-Functions"><a class="docs-heading-anchor" href="#Migration-from-Population-Functions">Migration from Population Functions</a><a id="Migration-from-Population-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Migration-from-Population-Functions" title="Permalink"></a></h2><p>If you were previously using population-specific functions:</p><pre><code class="language-julia hljs"># OLD: Population-specific API (removed in v1.1.0)
scenario = create_scenario(&quot;policy&quot;, data; income = 50000)  # REMOVED
compiled_scenario = compile_formula(model, scenario.data)
population_effect = compute_population_effect(compiled_scenario, ...)

# CURRENT: Simple data modification + loops
cf_data = merge(data, (income = fill(log(50000), n_rows),))

effects = Vector{Float64}(undef, n_rows)
for row in 1:n_rows
    compiled(output_buffer, cf_data, row)
    effects[row] = dot(β, output_buffer)
end
population_effect = mean(effects)</code></pre><p>The row-wise approach is:</p><ul><li><strong>Faster</strong>: Simple loops with minimal overhead</li><li>Extensible aggregation: Supports custom aggregation functions beyond simple averaging</li><li><strong>More transparent</strong>: Can examine individual-level results</li><li><strong>Memory efficient</strong>: O(1) usage vs O(n) for data copying approaches</li></ul><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>Population analysis in FormulaCompiler is achieved through:</p><ol><li><strong>Individual-level computation</strong>: Use existing row-wise functions (<code>marginal_effects_eta!</code>, etc.)</li><li><strong>Counterfactual scenarios</strong>: Use <code>CounterfactualVector</code> system for single-observation perturbations</li><li><strong>Simple aggregation</strong>: Apply standard arithmetic (mean, weighted average, etc.)</li></ol><p>This simple loop-based approach provides superior performance, flexibility, and clarity.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 8 February 2026 19:56">Sunday 8 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
