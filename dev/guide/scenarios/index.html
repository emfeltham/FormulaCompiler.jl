<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scenario Analysis · FormulaCompiler.jl</title><meta name="title" content="Scenario Analysis · FormulaCompiler.jl"/><meta property="og:title" content="Scenario Analysis · FormulaCompiler.jl"/><meta property="twitter:title" content="Scenario Analysis · FormulaCompiler.jl"/><meta name="description" content="Documentation for FormulaCompiler.jl."/><meta property="og:description" content="Documentation for FormulaCompiler.jl."/><meta property="twitter:description" content="Documentation for FormulaCompiler.jl."/><meta property="og:url" content="https://emfeltham.github.io/FormulaCompiler.jl/guide/scenarios/"/><meta property="twitter:url" content="https://emfeltham.github.io/FormulaCompiler.jl/guide/scenarios/"/><link rel="canonical" href="https://emfeltham.github.io/FormulaCompiler.jl/guide/scenarios/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/mermaid.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FormulaCompiler.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../advanced_features/">Advanced Features</a></li><li><a class="tocitem" href="../categorical_mixtures/">Categorical Mixtures</a></li><li class="is-active"><a class="tocitem" href>Scenario Analysis</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Approach-1:-Direct-Data-Modification"><span>Approach 1: Direct Data Modification</span></a></li><li><a class="tocitem" href="#Approach-2:-Categorical-Contrasts-with-ContrastEvaluator"><span>Approach 2: Categorical Contrasts with ContrastEvaluator</span></a></li><li><a class="tocitem" href="#Approach-3:-Grid-Analysis-Patterns"><span>Approach 3: Grid Analysis Patterns</span></a></li><li><a class="tocitem" href="#Advanced-Patterns"><span>Advanced Patterns</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li><li><a class="tocitem" href="#Statistical-Considerations"><span>Statistical Considerations</span></a></li><li><a class="tocitem" href="#Integration-with-Statistical-Workflows"><span>Integration with Statistical Workflows</span></a></li><li><a class="tocitem" href="#Further-Reading"><span>Further Reading</span></a></li></ul></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../../integration/glm/">GLM.jl</a></li><li><a class="tocitem" href="../../integration/mixed_models/">MixedModels.jl</a></li><li><a class="tocitem" href="../../integration/standardized_predictors/">StandardizedPredictors.jl</a></li></ul></li><li><a class="tocitem" href="../../mathematical_foundation/">Mathematical Foundation</a></li><li><a class="tocitem" href="../../architecture/">Architecture</a></li><li><a class="tocitem" href="../../metaprogramming/">Metaprogramming</a></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Scenario Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scenario Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/emfeltham/FormulaCompiler.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/main/docs/src/guide/scenarios.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Counterfactual-Analysis"><a class="docs-heading-anchor" href="#Counterfactual-Analysis">Counterfactual Analysis</a><a id="Counterfactual-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Counterfactual-Analysis" title="Permalink"></a></h1><p>FormulaCompiler.jl provides efficient counterfactual analysis through simple, direct data manipulation and loop patterns.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>FormulaCompiler enables counterfactual analysis through three straightforward approaches:</p><ol><li><strong>Direct data modification</strong> - Use <code>merge()</code> for simple scenarios (1-10 comparisons)</li><li><strong>Batch contrast evaluation</strong> - Use <code>contrastevaluator()</code> for categorical contrasts (100+ comparisons)</li><li><strong>Population analysis</strong> - Use simple loops over rows for aggregated effects</li></ol><p>All approaches maintain zero-allocation performance and scale efficiently with dataset size.</p><h2 id="Approach-1:-Direct-Data-Modification"><a class="docs-heading-anchor" href="#Approach-1:-Direct-Data-Modification">Approach 1: Direct Data Modification</a><a id="Approach-1:-Direct-Data-Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-1:-Direct-Data-Modification" title="Permalink"></a></h2><h3 id="Basic-Treatment-Effect-Analysis"><a class="docs-heading-anchor" href="#Basic-Treatment-Effect-Analysis">Basic Treatment Effect Analysis</a><a id="Basic-Treatment-Effect-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Treatment-Effect-Analysis" title="Permalink"></a></h3><p>The simplest approach for counterfactual analysis is to create modified versions of your data and compare outcomes:</p><pre><code class="language-julia hljs">using FormulaCompiler, GLM, DataFrames, Tables, Statistics

# Setup data and model
df = DataFrame(
    y = randn(1000),
    x = randn(1000),
    treatment = rand(Bool, 1000),
    age = rand(18:80, 1000)
)

model = lm(@formula(y ~ x * treatment + age), df)
data = Tables.columntable(df)
compiled = compile_formula(model, data)
β = coef(model)

# Create counterfactual scenarios
n_rows = length(data.treatment)
data_treated = merge(data, (treatment = fill(true, n_rows),))
data_control = merge(data, (treatment = fill(false, n_rows),))

# Compare individual outcomes under different treatments
row_vec = Vector{Float64}(undef, length(compiled))

# Individual 1: treated vs control
compiled(row_vec, data_treated, 1)
effect_treated = dot(β, row_vec)

compiled(row_vec, data_control, 1)
effect_control = dot(β, row_vec)

individual_effect = effect_treated - effect_control
println(&quot;Individual 1 treatment effect: $(round(individual_effect, digits=3))&quot;)</code></pre><h3 id="Population-Average-Treatment-Effects"><a class="docs-heading-anchor" href="#Population-Average-Treatment-Effects">Population Average Treatment Effects</a><a id="Population-Average-Treatment-Effects-1"></a><a class="docs-heading-anchor-permalink" href="#Population-Average-Treatment-Effects" title="Permalink"></a></h3><p>Calculate average treatment effects across the population:</p><pre><code class="language-julia hljs"># Population analysis: loop over all individuals
n_individuals = nrow(df)
treatment_effects = Vector{Float64}(undef, n_individuals)

for i in 1:n_individuals
    # Effect if treated
    compiled(row_vec, data_treated, i)
    outcome_treated = dot(β, row_vec)

    # Effect if control
    compiled(row_vec, data_control, i)
    outcome_control = dot(β, row_vec)

    treatment_effects[i] = outcome_treated - outcome_control
end

# Summary statistics
avg_effect = mean(treatment_effects)
std_effect = std(treatment_effects)
println(&quot;Average treatment effect: $(round(avg_effect, digits=3)) ± $(round(std_effect, digits=3))&quot;)</code></pre><h3 id="Multi-Variable-Counterfactuals"><a class="docs-heading-anchor" href="#Multi-Variable-Counterfactuals">Multi-Variable Counterfactuals</a><a id="Multi-Variable-Counterfactuals-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Variable-Counterfactuals" title="Permalink"></a></h3><p>Modify multiple variables simultaneously:</p><pre><code class="language-julia hljs"># Policy scenario: everyone gets treatment + standardized age
standard_age = 40
data_policy = merge(data, (
    treatment = fill(true, n_rows),
    age = fill(standard_age, n_rows)
))

# Compare baseline vs policy for each individual
policy_effects = Vector{Float64}(undef, n_individuals)

for i in 1:n_individuals
    # Baseline outcome
    compiled(row_vec, data, i)
    baseline = dot(β, row_vec)

    # Policy outcome
    compiled(row_vec, data_policy, i)
    policy = dot(β, row_vec)

    policy_effects[i] = policy - baseline
end

avg_policy_effect = mean(policy_effects)
println(&quot;Average policy effect: $(round(avg_policy_effect, digits=3))&quot;)</code></pre><h3 id="Multiple-Scenario-Comparison"><a class="docs-heading-anchor" href="#Multiple-Scenario-Comparison">Multiple Scenario Comparison</a><a id="Multiple-Scenario-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Scenario-Comparison" title="Permalink"></a></h3><p>Compare several policy scenarios:</p><pre><code class="language-julia hljs"># Define scenarios to compare
scenarios = [
    (&quot;baseline&quot;, data),
    (&quot;universal_treatment&quot;, merge(data, (treatment = fill(true, n_rows),))),
    (&quot;universal_control&quot;, merge(data, (treatment = fill(false, n_rows),))),
    (&quot;young_treated&quot;, merge(data, (treatment = fill(true, n_rows), age = fill(30, n_rows)))),
    (&quot;old_treated&quot;, merge(data, (treatment = fill(true, n_rows), age = fill(60, n_rows))))
]

# Evaluate all scenarios
results = Dict{String, Vector{Float64}}()

for (name, scenario_data) in scenarios
    outcomes = Vector{Float64}(undef, n_individuals)

    for i in 1:n_individuals
        compiled(row_vec, scenario_data, i)
        outcomes[i] = dot(β, row_vec)
    end

    results[name] = outcomes
end

# Compare scenario means
println(&quot;\nScenario comparison:&quot;)
for (name, outcomes) in results
    println(&quot;  $(name): mean = $(round(mean(outcomes), digits=3))&quot;)
end</code></pre><h2 id="Approach-2:-Categorical-Contrasts-with-ContrastEvaluator"><a class="docs-heading-anchor" href="#Approach-2:-Categorical-Contrasts-with-ContrastEvaluator">Approach 2: Categorical Contrasts with ContrastEvaluator</a><a id="Approach-2:-Categorical-Contrasts-with-ContrastEvaluator-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-2:-Categorical-Contrasts-with-ContrastEvaluator" title="Permalink"></a></h2><p>For repeated categorical variable comparisons, use the zero-allocation contrast evaluator:</p><h3 id="Basic-Contrast-Evaluation"><a class="docs-heading-anchor" href="#Basic-Contrast-Evaluation">Basic Contrast Evaluation</a><a id="Basic-Contrast-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Contrast-Evaluation" title="Permalink"></a></h3><pre><code class="language-julia hljs">using CategoricalArrays

# Data with categorical variable
df_cat = DataFrame(
    y = randn(1000),
    x = randn(1000),
    region = categorical(rand([&quot;North&quot;, &quot;South&quot;, &quot;East&quot;, &quot;West&quot;], 1000))
)

model_cat = lm(@formula(y ~ x * region), df_cat)
data_cat = Tables.columntable(df_cat)
compiled_cat = compile_formula(model_cat, data_cat)

# Create contrast evaluator for zero-allocation batch processing
evaluator = contrastevaluator(compiled_cat, data_cat, [:region])
contrast_buf = Vector{Float64}(undef, length(compiled_cat))

# Single contrast: North vs South for individual 1
contrast_modelrow!(contrast_buf, evaluator, 1, :region, &quot;North&quot;, &quot;South&quot;)
regional_difference = dot(coef(model_cat), contrast_buf)
println(&quot;North vs South effect: $(round(regional_difference, digits=3))&quot;)</code></pre><h3 id="Batch-Contrast-Processing"><a class="docs-heading-anchor" href="#Batch-Contrast-Processing">Batch Contrast Processing</a><a id="Batch-Contrast-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Contrast-Processing" title="Permalink"></a></h3><p>Process many contrasts with zero allocations:</p><pre><code class="language-julia hljs"># Compare all individuals: North vs South
n_rows = nrow(df_cat)
regional_effects = Vector{Float64}(undef, n_rows)

for i in 1:n_rows
    contrast_modelrow!(contrast_buf, evaluator, i, :region, &quot;North&quot;, &quot;South&quot;)
    regional_effects[i] = dot(coef(model_cat), contrast_buf)
end

println(&quot;Average North vs South effect: $(round(mean(regional_effects), digits=3))&quot;)</code></pre><h3 id="Gradient-Computation-for-Uncertainty"><a class="docs-heading-anchor" href="#Gradient-Computation-for-Uncertainty">Gradient Computation for Uncertainty</a><a id="Gradient-Computation-for-Uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Computation-for-Uncertainty" title="Permalink"></a></h3><p>Compute parameter gradients for standard errors:</p><pre><code class="language-julia hljs"># Parameter gradient for delta method (FormulaCompiler computational primitive)
∇β = Vector{Float64}(undef, length(compiled_cat))
contrast_gradient!(∇β, evaluator, 1, :region, &quot;North&quot;, &quot;South&quot;, coef(model_cat))

# Standard error using delta method (requires Margins.jl)
using Margins
vcov_matrix = vcov(model_cat)
se = delta_method_se(∇β, vcov_matrix)
println(&quot;Standard error: $(round(se, digits=3))&quot;)</code></pre><h2 id="Approach-3:-Grid-Analysis-Patterns"><a class="docs-heading-anchor" href="#Approach-3:-Grid-Analysis-Patterns">Approach 3: Grid Analysis Patterns</a><a id="Approach-3:-Grid-Analysis-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-3:-Grid-Analysis-Patterns" title="Permalink"></a></h2><h3 id="Systematic-Parameter-Exploration"><a class="docs-heading-anchor" href="#Systematic-Parameter-Exploration">Systematic Parameter Exploration</a><a id="Systematic-Parameter-Exploration-1"></a><a class="docs-heading-anchor-permalink" href="#Systematic-Parameter-Exploration" title="Permalink"></a></h3><p>Explore multiple parameter combinations:</p><pre><code class="language-julia hljs"># Define parameter grid
treatment_values = [false, true]
age_values = [30, 40, 50, 60]
x_values = [-1.0, 0.0, 1.0]

# Create all combinations
n_scenarios = length(treatment_values) * length(age_values) * length(x_values)
scenario_results = Matrix{Float64}(undef, n_scenarios, n_individuals)

scenario_idx = 1
for treat in treatment_values
    for age_val in age_values
        for x_val in x_values
            # Create scenario data
            scenario_data = merge(data, (
                treatment = fill(treat, n_rows),
                age = fill(age_val, n_rows),
                x = fill(x_val, n_rows)
            ))

            # Evaluate for all individuals
            for i in 1:n_individuals
                compiled(row_vec, scenario_data, i)
                scenario_results[scenario_idx, i] = dot(β, row_vec)
            end

            scenario_idx += 1
        end
    end
end

# Analyze results
scenario_means = [mean(scenario_results[i, :]) for i in 1:n_scenarios]
best_scenario = argmax(scenario_means)
println(&quot;Best scenario index: $best_scenario with mean outcome: $(round(scenario_means[best_scenario], digits=3))&quot;)</code></pre><h3 id="Efficient-Batched-Evaluation"><a class="docs-heading-anchor" href="#Efficient-Batched-Evaluation">Efficient Batched Evaluation</a><a id="Efficient-Batched-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Efficient-Batched-Evaluation" title="Permalink"></a></h3><p>For very large grids, batch the evaluation:</p><pre><code class="language-julia hljs">function evaluate_scenario_grid(compiled, base_data, param_values, β)
    &quot;&quot;&quot;Efficiently evaluate parameter grid&quot;&quot;&quot;
    n_rows = length(first(base_data))
    row_vec = Vector{Float64}(undef, length(compiled))

    results = Dict()

    for (name, values) in param_values
        # Create scenario
        scenario_data = merge(base_data, Dict(name =&gt; fill(values, n_rows)))

        # Evaluate population
        outcomes = Vector{Float64}(undef, n_rows)
        for i in 1:n_rows
            compiled(row_vec, scenario_data, i)
            outcomes[i] = dot(β, row_vec)
        end

        results[name =&gt; values] = mean(outcomes)
    end

    return results
end

# Usage
param_grid = Dict(
    :treatment =&gt; [true, false],
    :age =&gt; [30, 40, 50, 60]
)

grid_results = evaluate_scenario_grid(compiled, data, param_grid, β)</code></pre><h2 id="Advanced-Patterns"><a class="docs-heading-anchor" href="#Advanced-Patterns">Advanced Patterns</a><a id="Advanced-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Patterns" title="Permalink"></a></h2><h3 id="Sensitivity-Analysis"><a class="docs-heading-anchor" href="#Sensitivity-Analysis">Sensitivity Analysis</a><a id="Sensitivity-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Sensitivity-Analysis" title="Permalink"></a></h3><p>Test model sensitivity to parameter changes:</p><pre><code class="language-julia hljs"># Vary age systematically
age_range = 20:10:70
sensitivity_results = Vector{Float64}(undef, length(age_range))

for (idx, age_val) in enumerate(age_range)
    scenario_data = merge(data, (age = fill(age_val, n_rows),))

    outcomes = Vector{Float64}(undef, n_individuals)
    for i in 1:n_individuals
        compiled(row_vec, scenario_data, i)
        outcomes[i] = dot(β, row_vec)
    end

    sensitivity_results[idx] = mean(outcomes)
end

# Plot or analyze sensitivity
println(&quot;Age sensitivity:&quot;)
for (age_val, result) in zip(age_range, sensitivity_results)
    println(&quot;  Age $age_val: $(round(result, digits=3))&quot;)
end</code></pre><h3 id="Bootstrap-Confidence-Intervals"><a class="docs-heading-anchor" href="#Bootstrap-Confidence-Intervals">Bootstrap Confidence Intervals</a><a id="Bootstrap-Confidence-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Bootstrap-Confidence-Intervals" title="Permalink"></a></h3><p>Compute uncertainty via bootstrap:</p><pre><code class="language-julia hljs">using Random

function bootstrap_treatment_effect(df, model_formula, n_boot=1000)
    Random.seed!(123)
    n_obs = nrow(df)

    boot_effects = Vector{Float64}(undef, n_boot)

    for b in 1:n_boot
        # Bootstrap sample
        boot_indices = rand(1:n_obs, n_obs)
        boot_df = df[boot_indices, :]

        # Fit model
        boot_model = lm(model_formula, boot_df)
        boot_data = Tables.columntable(boot_df)
        boot_compiled = compile_formula(boot_model, boot_data)
        boot_β = coef(boot_model)

        # Create treatment scenarios
        n_boot_rows = nrow(boot_df)
        treated_data = merge(boot_data, (treatment = fill(true, n_boot_rows),))
        control_data = merge(boot_data, (treatment = fill(false, n_boot_rows),))

        # Compute average effect
        row_vec = Vector{Float64}(undef, length(boot_compiled))
        effects = Vector{Float64}(undef, n_boot_rows)

        for i in 1:n_boot_rows
            boot_compiled(row_vec, treated_data, i)
            treated = dot(boot_β, row_vec)

            boot_compiled(row_vec, control_data, i)
            control = dot(boot_β, row_vec)

            effects[i] = treated - control
        end

        boot_effects[b] = mean(effects)
    end

    return boot_effects
end

# Compute bootstrap CI
boot_results = bootstrap_treatment_effect(df, @formula(y ~ x * treatment + age), 500)
ci_lower = quantile(boot_results, 0.025)
ci_upper = quantile(boot_results, 0.975)
println(&quot;95% CI: [$(round(ci_lower, digits=3)), $(round(ci_upper, digits=3))]&quot;)</code></pre><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><h3 id="When-to-Use-Each-Approach"><a class="docs-heading-anchor" href="#When-to-Use-Each-Approach">When to Use Each Approach</a><a id="When-to-Use-Each-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Each-Approach" title="Permalink"></a></h3><p><strong>Direct data modification</strong> (<code>merge()</code>):</p><ul><li>Simple scenarios (1-10 comparisons)</li><li>Exploratory analysis</li><li>Quick prototyping</li><li>Small to medium datasets</li></ul><p><strong>Contrast evaluator</strong> (<code>contrastevaluator()</code>):</p><ul><li>Categorical variable comparisons</li><li>Batch processing (100+ contrasts)</li><li>Need for uncertainty quantification</li><li>Production pipelines</li></ul><p><strong>Simple loops</strong>:</p><ul><li>Population-level analysis</li><li>Any scenario type</li><li>Maximum flexibility</li><li>Large-scale analysis</li></ul><h3 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h3><ol><li><strong>Pre-allocate buffers</strong>: Reuse <code>row_vec</code> and result vectors</li><li><strong>Compile once</strong>: Cache compiled formulas across scenarios</li><li><strong>Batch operations</strong>: Group related evaluations</li><li><strong>Use views</strong>: Avoid unnecessary copies with <code>view()</code></li></ol><h3 id="Memory-Efficiency"><a class="docs-heading-anchor" href="#Memory-Efficiency">Memory Efficiency</a><a id="Memory-Efficiency-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Efficiency" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Good: Pre-allocate and reuse
row_vec = Vector{Float64}(undef, length(compiled))
results = Vector{Float64}(undef, n_individuals)

for i in 1:n_individuals
    compiled(row_vec, scenario_data, i)
    results[i] = dot(β, row_vec)
end

# Avoid: Allocating each iteration
for i in 1:n_individuals
    row_vec = modelrow(compiled, scenario_data, i)  # Allocates!
    results[i] = dot(β, row_vec)
end</code></pre><h2 id="Statistical-Considerations"><a class="docs-heading-anchor" href="#Statistical-Considerations">Statistical Considerations</a><a id="Statistical-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Statistical-Considerations" title="Permalink"></a></h2><h3 id="Causal-Interpretation"><a class="docs-heading-anchor" href="#Causal-Interpretation">Causal Interpretation</a><a id="Causal-Interpretation-1"></a><a class="docs-heading-anchor-permalink" href="#Causal-Interpretation" title="Permalink"></a></h3><p>Remember that counterfactual estimates depend on modeling assumptions:</p><ul><li><strong>Unconfoundedness</strong>: No unmeasured confounders</li><li><strong>Positivity</strong>: All individuals have positive probability of each treatment</li><li><strong>Consistency</strong>: Treatment definition is well-specified</li><li><strong>Model specification</strong>: Correct functional form</li></ul><h3 id="Uncertainty-Quantification"><a class="docs-heading-anchor" href="#Uncertainty-Quantification">Uncertainty Quantification</a><a id="Uncertainty-Quantification-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-Quantification" title="Permalink"></a></h3><p>Account for parameter uncertainty:</p><ul><li>Use bootstrap for confidence intervals</li><li>Apply delta method for analytic standard errors</li><li>Consider robust/clustered standard errors when appropriate</li></ul><h3 id="Sensitivity-Analysis-2"><a class="docs-heading-anchor" href="#Sensitivity-Analysis-2">Sensitivity Analysis</a><a class="docs-heading-anchor-permalink" href="#Sensitivity-Analysis-2" title="Permalink"></a></h3><p>Test robustness:</p><ul><li>Vary model specifications</li><li>Check sensitivity to parameter ranges</li><li>Examine heterogeneous effects across subgroups</li></ul><h2 id="Integration-with-Statistical-Workflows"><a class="docs-heading-anchor" href="#Integration-with-Statistical-Workflows">Integration with Statistical Workflows</a><a id="Integration-with-Statistical-Workflows-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Statistical-Workflows" title="Permalink"></a></h2><h3 id="Model-Comparison"><a class="docs-heading-anchor" href="#Model-Comparison">Model Comparison</a><a id="Model-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Comparison" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Compare models under fixed counterfactual
models = [
    lm(@formula(y ~ x + treatment), df),
    lm(@formula(y ~ x * treatment), df),
    lm(@formula(y ~ x * treatment + age), df)
]

scenario_data = merge(data, (treatment = fill(true, n_rows),))

for (i, model) in enumerate(models)
    compiled = compile_formula(model, data)
    β = coef(model)
    row_vec = Vector{Float64}(undef, length(compiled))

    predictions = Vector{Float64}(undef, n_individuals)
    for j in 1:n_individuals
        compiled(row_vec, scenario_data, j)
        predictions[j] = dot(β, row_vec)
    end

    println(&quot;Model $i mean prediction: $(round(mean(predictions), digits=3))&quot;)
end</code></pre><h2 id="Further-Reading"><a class="docs-heading-anchor" href="#Further-Reading">Further Reading</a><a id="Further-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Reading" title="Permalink"></a></h2><ul><li><a href="../advanced_features/">Advanced Features</a> - Additional computational patterns</li><li><a href="../categorical_mixtures/">Categorical Mixtures</a> - Profile-based marginal effects</li><li><a href="../../examples/#Examples">Examples</a> - Real-world applications</li><li><a href="../../api/#API-Reference">API Reference</a> - Complete function documentation</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../categorical_mixtures/">« Categorical Mixtures</a><a class="docs-footer-nextpage" href="../performance/">Performance Tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 10 February 2026 00:58">Tuesday 10 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
