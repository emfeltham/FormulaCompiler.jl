var documenterSearchIndex = {"docs":
[{"location":"mathematical_foundation/#Mathematical-and-Statistical-Foundation","page":"Mathematical Foundation","title":"Mathematical and Statistical Foundation","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"This document provides a comprehensive walkthrough of the mathematical and statistical concepts underlying FormulaCompiler.jl, from basic formula representation to advanced derivative computations and variance estimation.","category":"page"},{"location":"mathematical_foundation/#Table-of-Contents","page":"Mathematical Foundation","title":"Table of Contents","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Statistical Model Representation\nFormula Compilation Mathematics\nPosition Mapping Theory\nDerivative Computation\nMarginal Effects Theory\nVariance Estimation and Standard Errors\nComputational Efficiency Theory","category":"page"},{"location":"mathematical_foundation/#Statistical-Model-Representation","page":"Mathematical Foundation","title":"Statistical Model Representation","text":"","category":"section"},{"location":"mathematical_foundation/#Linear-Models","page":"Mathematical Foundation","title":"Linear Models","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"FormulaCompiler.jl operates on statistical models of the form:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbbEy_i = mathbfx_i^T boldsymbolbeta","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"where:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"y_i\nis the response for observation i\nmathbfx_i in mathbbR^p\nis the model matrix row (predictor vector)\nboldsymbolbeta in mathbbR^p\nis the parameter vector","category":"page"},{"location":"mathematical_foundation/#Generalized-Linear-Models","page":"Mathematical Foundation","title":"Generalized Linear Models","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For GLMs, we have:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbbEy_i = mu_i = g^-1(eta_i)","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"eta_i = mathbfx_i^T boldsymbolbeta","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"where:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"eta_i\nis the linear predictor\ng(cdot)\nis the link function\nmu_i\nis the expected response","category":"page"},{"location":"mathematical_foundation/#Mixed-Effects-Models","page":"Mathematical Foundation","title":"Mixed Effects Models","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For linear mixed models:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbbEy_i = mathbfx_i^T boldsymbolbeta + mathbfz_i^T mathbfb","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"where FormulaCompiler extracts only the fixed effects component mathbfx_i^T boldsymbolbeta.","category":"page"},{"location":"mathematical_foundation/#Formula-Compilation-Mathematics","page":"Mathematical Foundation","title":"Formula Compilation Mathematics","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"FormulaCompiler.jl transforms statistical formulas through a systematic compilation process:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"(Image: Compilation Pipeline)","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Figure 1: The compilation pipeline transforms statistical formulas into position-mapped, type-specialized evaluators through systematic decomposition and analysis.","category":"page"},{"location":"mathematical_foundation/#Term-Decomposition","page":"Mathematical Foundation","title":"Term Decomposition","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"A statistical formula like y ~ x + z + x*group is decomposed into atomic operations:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbfx_i = beginbmatrix\n1 \nx_i \nz_i \nx_i cdot mathbf1(textgroup_i = textB) \nx_i cdot mathbf1(textgroup_i = textC)\nendbmatrix","category":"page"},{"location":"mathematical_foundation/#Categorical-Variables","page":"Mathematical Foundation","title":"Categorical Variables","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For a categorical variable with K levels using treatment contrast:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textContrastMatrix = beginbmatrix\n0  0  cdots  0 \n1  0  cdots  0 \n0  1  cdots  0 \nvdots  vdots  ddots  vdots \n0  0  cdots  1\nendbmatrix in mathbbR^K times (K-1)","category":"page"},{"location":"mathematical_foundation/#Function-Application","page":"Mathematical Foundation","title":"Function Application","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For transformed variables like log(x):","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textFunctionOp x_i mapsto f(x_i)","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"where f is applied element-wise with appropriate domain checking.","category":"page"},{"location":"mathematical_foundation/#Position-Mapping","page":"Mathematical Foundation","title":"Position Mapping","text":"","category":"section"},{"location":"mathematical_foundation/#Core-Concept","page":"Mathematical Foundation","title":"Core Concept","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The key innovation is mapping each formula term to a fixed position in the output vector at compile time:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textTerm_j rightarrow textPosition_j in 1 2 ldots p","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"This enables:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbfx_ij = textEvaluate(textTerm_j textdata i)","category":"page"},{"location":"mathematical_foundation/#Type-Specialization","page":"Mathematical Foundation","title":"Type Specialization","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Each operation is embedded in Julia's type system:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"struct LoadOp{Col} end           # Load column Col\nstruct FunctionOp{Col, F} end    # Apply function F to column Col  \nstruct InteractionOp{A, B} end   # Multiply terms A and B","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"This allows the compiler to generate specialized code for each specific formula.","category":"page"},{"location":"mathematical_foundation/#Scratch-Space-Management","page":"Mathematical Foundation","title":"Scratch Space Management","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Intermediate results use a compile-time allocated scratch space:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textScratch in mathbbR^s quad textwhere  s = textmax intermediate width","category":"page"},{"location":"mathematical_foundation/#Derivative-Computation","page":"Mathematical Foundation","title":"Derivative Computation","text":"","category":"section"},{"location":"mathematical_foundation/#Jacobian-Matrix","page":"Mathematical Foundation","title":"Jacobian Matrix","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For derivatives with respect to variables mathbfv = v_1 ldots v_k^T:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbfJ = fracpartial mathbfxpartial mathbfv^T = beginbmatrix\nfracpartial x_1partial v_1  fracpartial x_1partial v_2  cdots  fracpartial x_1partial v_k \nfracpartial x_2partial v_1  fracpartial x_2partial v_2  cdots  fracpartial x_2partial v_k \nvdots  vdots  ddots  vdots \nfracpartial x_ppartial v_1  fracpartial x_ppartial v_2  cdots  fracpartial x_ppartial v_k\nendbmatrix in mathbbR^p times k","category":"page"},{"location":"mathematical_foundation/#Automatic-Differentiation","page":"Mathematical Foundation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"FormulaCompiler uses ForwardDiff.jl for automatic differentiation:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"x_j = f_j(v_1 ldots v_k) Rightarrow fracpartial x_jpartial v_i = f_j(v_i)","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Dual numbers compute derivatives exactly:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"f(a + bvarepsilon) = f(a) + bf(a)varepsilon","category":"page"},{"location":"mathematical_foundation/#Finite-Differences","page":"Mathematical Foundation","title":"Finite Differences","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For the finite difference backend:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"fracpartial x_jpartial v_i approx fracf_j(v_i + h) - f_j(v_i - h)2h","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"where h = epsilon^13 max(1 v_i) and epsilon is machine precision.","category":"page"},{"location":"mathematical_foundation/#Single-Column-Extraction","page":"Mathematical Foundation","title":"Single-Column Extraction","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For computational efficiency, we can compute individual Jacobian columns:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbfJ_cdotk = fracpartial mathbfxpartial v_k in mathbbR^p","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"This avoids computing the full Jacobian when only one column is needed.","category":"page"},{"location":"mathematical_foundation/#Marginal-Effects","page":"Mathematical Foundation","title":"Marginal Effects","text":"","category":"section"},{"location":"mathematical_foundation/#Definition","page":"Mathematical Foundation","title":"Definition","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"A marginal effect measures the change in the expected response due to a small change in a predictor:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textME_v_k = fracpartial mathbbEypartial v_k","category":"page"},{"location":"mathematical_foundation/#Linear-Predictor-Case-(η)","page":"Mathematical Foundation","title":"Linear Predictor Case (η)","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For the linear predictor eta = mathbfx^T boldsymbolbeta:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"fracpartial etapartial v_k = fracpartial (mathbfx^T boldsymbolbeta)partial v_k = left(fracpartial mathbfxpartial v_kright)^T boldsymbolbeta = mathbfJ_cdotk^T boldsymbolbeta","category":"page"},{"location":"mathematical_foundation/#Mean-Response-Case-(μ)","page":"Mathematical Foundation","title":"Mean Response Case (μ)","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For GLMs where mu = g^-1(eta):","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"fracpartial mupartial v_k = fracdmudeta fracpartial etapartial v_k = g(eta) cdot mathbfJ_cdotk^T boldsymbolbeta","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"where g(eta) = fracdmudeta is the derivative of the inverse link function.","category":"page"},{"location":"mathematical_foundation/#Average-Marginal-Effects","page":"Mathematical Foundation","title":"Average Marginal Effects","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Average marginal effects (AME) average the marginal effect across observations:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textAME_v_k = frac1n sum_i=1^n fracpartial mathbbEy_ipartial v_k","category":"page"},{"location":"mathematical_foundation/#Variance-Estimation-and-Standard-Errors","page":"Mathematical Foundation","title":"Variance Estimation and Standard Errors","text":"","category":"section"},{"location":"mathematical_foundation/#Delta-Method","page":"Mathematical Foundation","title":"Delta Method","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The delta method provides standard errors for smooth functions of estimated parameters. For a function m(boldsymbolbeta):","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textVar(m(hatboldsymbolbeta)) approx mathbfg^T boldsymbolSigma mathbfg","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"where:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbfg = fracpartial mpartial boldsymbolbeta\nis the gradient\nboldsymbolSigma = textVar(hatboldsymbolbeta)\nis the parameter covariance matrix","category":"page"},{"location":"mathematical_foundation/#Standard-Error-Computation","page":"Mathematical Foundation","title":"Standard Error Computation","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textSE(m(hatboldsymbolbeta)) = sqrtmathbfg^T boldsymbolSigma mathbfg","category":"page"},{"location":"mathematical_foundation/#Marginal-Effect-Standard-Errors","page":"Mathematical Foundation","title":"Marginal Effect Standard Errors","text":"","category":"section"},{"location":"mathematical_foundation/#Linear-Predictor-Case","page":"Mathematical Foundation","title":"Linear Predictor Case","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For marginal effects on eta:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"m = mathbfJ_cdotk^T boldsymbolbeta Rightarrow mathbfg = fracpartial mpartial boldsymbolbeta = mathbfJ_cdotk","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Therefore:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textSE(textME_etak) = sqrtmathbfJ_cdotk^T boldsymbolSigma mathbfJ_cdotk","category":"page"},{"location":"mathematical_foundation/#Mean-Response-Case","page":"Mathematical Foundation","title":"Mean Response Case","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For marginal effects on mu with link function g:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"m = g(eta) cdot mathbfJ_cdotk^T boldsymbolbeta","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The gradient is:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbfg = fracpartial mpartial boldsymbolbeta = g(eta) mathbfJ_cdotk + (mathbfJ_cdotk^T boldsymbolbeta) g(eta) mathbfx","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"where mathbfx is the model matrix row and g(eta) is the second derivative.","category":"page"},{"location":"mathematical_foundation/#Average-Marginal-Effects-2","page":"Mathematical Foundation","title":"Average Marginal Effects","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For AME, the gradient is the average of individual gradients:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"mathbfg_textAME = frac1n sum_i=1^n mathbfg_i","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"By linearity of expectation:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"textVar(textAME) = mathbfg_textAME^T boldsymbolSigma mathbfg_textAME","category":"page"},{"location":"mathematical_foundation/#Link-Function-Derivatives","page":"Mathematical Foundation","title":"Link Function Derivatives","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Common link functions and their derivatives:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Link g(mu) g^-1(eta) fracdmudeta fracd^2mudeta^2\nIdentity mu eta 1 0\nLog log(mu) exp(eta) exp(eta) exp(eta)\nLogit log(fracmu1-mu) frac11+e^-eta mu(1-mu) mu(1-mu)(1-2mu)","category":"page"},{"location":"mathematical_foundation/#Computational-Efficiency","page":"Mathematical Foundation","title":"Computational Efficiency","text":"","category":"section"},{"location":"mathematical_foundation/#Zero-Allocation-Design","page":"Mathematical Foundation","title":"Zero-Allocation Design","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The key to zero-allocation performance is eliminating runtime memory allocation:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Compile-time type specialization: All operations encoded in types\nFixed memory layout: Pre-allocated buffers reused across calls\nStack allocation: Small temporary values on the stack\nIn-place operations: Modify existing arrays rather than creating new ones","category":"page"},{"location":"mathematical_foundation/#Position-Mapping-Efficiency","page":"Mathematical Foundation","title":"Position Mapping Efficiency","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Traditional approach:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"O(p cdot textcomplexity(textformula))","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Position mapping approach:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"O(p) text with compile-time  O(textcomplexity(textformula))","category":"page"},{"location":"mathematical_foundation/#Memory-Complexity","page":"Mathematical Foundation","title":"Memory Complexity","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Traditional: O(np) for full model matrix\nFormulaCompiler: O(p) per row evaluation\nScenarios: O(1) via OverrideVector regardless of n","category":"page"},{"location":"mathematical_foundation/#Derivative-Efficiency","page":"Mathematical Foundation","title":"Derivative Efficiency","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Full Jacobian: O(pk) computation and storage\nSingle column: O(p) computation and storage  \nAME accumulation: O(np) time, O(p) space","category":"page"},{"location":"mathematical_foundation/#Backend-Selection-Trade-offs","page":"Mathematical Foundation","title":"Backend Selection Trade-offs","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Backend Speed Memory Accuracy\n:fd Medium 0 bytes Good\n:ad Fast Small Excellent","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Choose :fd for production AME (many rows), :ad for small samples requiring high accuracy.","category":"page"},{"location":"mathematical_foundation/#Implementation-Notes","page":"Mathematical Foundation","title":"Implementation Notes","text":"","category":"section"},{"location":"mathematical_foundation/#Type-Stability","page":"Mathematical Foundation","title":"Type Stability","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"All functions maintain type stability:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"f(x::Float64)::Float64  # Compiler can optimize aggressively","category":"page"},{"location":"mathematical_foundation/#Generated-Functions","page":"Mathematical Foundation","title":"Generated Functions","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Critical paths use @generated functions to move computation to compile time:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"@generated function evaluate(compiled::UnifiedCompiled{T,Ops}, ...)\n    # Generate specialized code based on Ops type parameter\n    return quote\n        # Unrolled, type-stable operations\n    end\nend","category":"page"},{"location":"mathematical_foundation/#Numerical-Stability","page":"Mathematical Foundation","title":"Numerical Stability","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Finite differences: Adaptive step size based on magnitude\nLink functions: Numerical safeguards for extreme values  \nMatrix operations: Use stable BLAS routines","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"This mathematical foundation enables FormulaCompiler.jl to achieve both computational efficiency and statistical accuracy, making it suitable as a foundation for advanced statistical computing applications.","category":"page"},{"location":"guide/scenarios/#Scenario-Analysis","page":"Scenario Analysis","title":"Scenario Analysis","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"FormulaCompiler.jl's scenario system enables efficient \"what-if\" analysis and counterfactual modeling with minimal memory overhead.","category":"page"},{"location":"guide/scenarios/#Overview","page":"Scenario Analysis","title":"Overview","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"The scenario system allows you to:","category":"page"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"Override specific variables while keeping others unchanged\nCreate policy scenarios for analysis\nGenerate scenario grids for comprehensive analysis\nPerform efficient counterfactual analysis\nHandle missing data patterns","category":"page"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"All with minimal memory allocation using the OverrideVector system.","category":"page"},{"location":"guide/scenarios/#Scenario-Workflow","page":"Scenario Analysis","title":"Scenario Workflow","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"(Image: Diagram)","category":"page"},{"location":"guide/scenarios/#Basic-Scenario-Creation","page":"Scenario Analysis","title":"Basic Scenario Creation","text":"","category":"section"},{"location":"guide/scenarios/#Simple-Overrides","page":"Scenario Analysis","title":"Simple Overrides","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"using FormulaCompiler, DataFrames, Tables, GLM\n\n# Setup data\ndf = DataFrame(\n    y = randn(1000),\n    x = randn(1000),\n    treatment = rand(Bool, 1000),\n    age = rand(18:80, 1000),\n    income = rand(20000:100000, 1000)\n)\n\ndata = Tables.columntable(df)\nmodel = lm(@formula(y ~ x * treatment + age + log(income)), df)\ncompiled = compile_formula(model, data)\n\n# Create scenarios\nbaseline = create_scenario(\"baseline\", data)\n\n# Treatment effect scenario\ntreatment_scenario = create_scenario(\"treatment_on\", data;\n    treatment = true\n)\n\n# Policy scenario: everyone gets average income\npolicy_scenario = create_scenario(\"income_equality\", data;\n    income = mean(df.income)\n)\n\n# Complex scenario with multiple overrides\nintervention = create_scenario(\"intervention\", data;\n    treatment = true,\n    age = 30,           # Set everyone to age 30\n    income = 50000      # Set everyone to $50k income\n)","category":"page"},{"location":"guide/scenarios/#Evaluating-Scenarios","page":"Scenario Analysis","title":"Evaluating Scenarios","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"row_vec = Vector{Float64}(undef, length(compiled))\n\n# Compare scenarios for individual 100\nindividual = 100\n\ncompiled(row_vec, baseline.data, individual)\nbaseline_prediction = copy(row_vec)\n\ncompiled(row_vec, treatment_scenario.data, individual)  \ntreatment_prediction = copy(row_vec)\n\ncompiled(row_vec, intervention.data, individual)\nintervention_prediction = copy(row_vec)\n\n# Calculate treatment effects\ntreatment_effect = treatment_prediction .- baseline_prediction\nintervention_effect = intervention_prediction .- baseline_prediction","category":"page"},{"location":"guide/scenarios/#Scenario-Collections","page":"Scenario Analysis","title":"Scenario Collections","text":"","category":"section"},{"location":"guide/scenarios/#Creating-Scenario-Grids","page":"Scenario Analysis","title":"Creating Scenario Grids","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"Generate all combinations of scenario parameters:","category":"page"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"# Create a 2×3×2 grid of scenarios\npolicy_grid = create_scenario_grid(\"policy_analysis\", data, Dict(\n    :treatment => [false, true],\n    :income => [30000, 50000, 80000],\n    :region => [\"urban\", \"rural\"]\n))\n\nprintln(\"Created $(length(policy_grid)) scenarios\")  # 12 scenarios\n\n# Evaluate all scenarios for a specific individual\nindividual = 1\nresults = Matrix{Float64}(undef, length(policy_grid), length(compiled))\n\nfor (i, scenario) in enumerate(policy_grid)\n    compiled(view(results, i, :), scenario.data, individual)\nend\n\n# Results matrix: each row is one scenario combination","category":"page"},{"location":"guide/scenarios/#Named-Scenario-Collections","page":"Scenario Analysis","title":"Named Scenario Collections","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"# Create multiple related scenarios\nscenarios = ScenarioCollection(\"treatment_analysis\")\n\nadd_scenario!(scenarios, \"control\", data; treatment = false)\nadd_scenario!(scenarios, \"low_dose\", data; treatment = true, dose = 50)  \nadd_scenario!(scenarios, \"high_dose\", data; treatment = true, dose = 100)\nadd_scenario!(scenarios, \"placebo\", data; treatment = false, placebo = true)\n\n# Evaluate all scenarios\nresults = evaluate_scenarios(compiled, scenarios, individual)\n\n# Access by name\ncontrol_result = results[\"control\"]\ntreatment_result = results[\"high_dose\"]","category":"page"},{"location":"guide/scenarios/#Advanced-Scenario-Patterns","page":"Scenario Analysis","title":"Advanced Scenario Patterns","text":"","category":"section"},{"location":"guide/scenarios/#Dynamic-Scenario-Modification","page":"Scenario Analysis","title":"Dynamic Scenario Modification","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"scenario = create_scenario(\"dynamic\", data; x = 1.0)\n\n# Modify scenarios iteratively\nfor new_treatment_value in [false, true]\n    set_override!(scenario, :treatment, new_treatment_value)\n    \n    for new_age in [25, 35, 45, 55, 65]\n        set_override!(scenario, :age, new_age)\n        \n        # Evaluate current scenario\n        compiled(row_vec, scenario.data, individual)\n        println(\"Treatment: $new_treatment_value, Age: $new_age, Prediction: $(row_vec[1])\")\n    end\nend\n\n# Bulk updates\nupdate_scenario!(scenario; \n    treatment = true,\n    age = 40,\n    income = 60000,\n    new_policy = true\n)\n\n# Remove specific overrides\nremove_override!(scenario, :new_policy)","category":"page"},{"location":"guide/scenarios/#Conditional-Scenarios","page":"Scenario Analysis","title":"Conditional Scenarios","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"Create scenarios with conditional logic:","category":"page"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"function create_conditional_scenario(name, data, condition_func)\n    scenario = create_scenario(name, data)\n    \n    # Apply conditions based on original data\n    if condition_func === :high_earners\n        # Override high earners (top 25%) to maximum income\n        high_income_threshold = quantile(df.income, 0.75)\n        max_income = maximum(df.income)\n        \n        # This would need custom implementation to be truly conditional\n        # For now, we can approximate with population statistics\n        set_override!(scenario, :income, max_income)\n    end\n    \n    return scenario\nend","category":"page"},{"location":"guide/scenarios/#Stochastic-Scenarios","page":"Scenario Analysis","title":"Stochastic Scenarios","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"Generate random scenario variations:","category":"page"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"using Random\n\nfunction create_random_scenarios(base_data, n_scenarios, seed=123)\n    Random.seed!(seed)\n    scenarios = ScenarioCollection(\"random_scenarios\")\n    \n    for i in 1:n_scenarios\n        scenario_name = \"random_$i\"\n        \n        # Random treatment assignment\n        treatment = rand(Bool)\n        \n        # Random age from realistic distribution\n        age = rand(25:65)\n        \n        # Random income with some correlation to age\n        base_income = 30000 + age * 800 + rand(Normal(0, 10000))\n        income = max(20000, base_income)\n        \n        add_scenario!(scenarios, scenario_name, base_data;\n            treatment = treatment,\n            age = age, \n            income = income\n        )\n    end\n    \n    return scenarios\nend\n\n# Generate 100 random scenarios\nrandom_scenarios = create_random_scenarios(data, 100)\n\n# Evaluate all random scenarios\nrandom_results = evaluate_scenarios(compiled, random_scenarios, individual)","category":"page"},{"location":"guide/scenarios/#Policy-Analysis-Applications","page":"Scenario Analysis","title":"Policy Analysis Applications","text":"","category":"section"},{"location":"guide/scenarios/#Treatment-Effect-Analysis","page":"Scenario Analysis","title":"Treatment Effect Analysis","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"# Create treatment vs. control scenarios\ncontrol = create_scenario(\"control\", data; treatment = false)\ntreated = create_scenario(\"treated\", data; treatment = true)\n\n# Calculate individual treatment effects\nn_individuals = 100\ntreatment_effects = Vector{Float64}(n_individuals)\n\nfor i in 1:n_individuals\n    compiled(row_vec, control.data, i)\n    control_pred = row_vec[1]  # Assuming outcome is first term\n    \n    compiled(row_vec, treated.data, i)\n    treated_pred = row_vec[1]\n    \n    treatment_effects[i] = treated_pred - control_pred\nend\n\n# Analyze distribution of treatment effects\nusing Statistics\nprintln(\"Mean treatment effect: $(mean(treatment_effects))\")\nprintln(\"Std treatment effect: $(std(treatment_effects))\")","category":"page"},{"location":"guide/scenarios/#Income-Redistribution-Analysis","page":"Scenario Analysis","title":"Income Redistribution Analysis","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"# Create scenarios with different income distributions\nincome_scenarios = Dict(\n    \"current\" => create_scenario(\"current\", data),\n    \"universal_basic\" => create_scenario(\"ubi\", data; income = 40000),\n    \"progressive\" => create_scenario(\"progressive\", data; \n        income = quantile(df.income, 0.5)  # Everyone gets median income\n    ),\n    \"equality\" => create_scenario(\"equality\", data; \n        income = mean(df.income)  # Everyone gets mean income\n    )\n)\n\n# Evaluate welfare outcomes under different policies\nwelfare_results = Dict{String, Vector{Float64}}()\n\nfor (policy_name, scenario) in income_scenarios\n    policy_outcomes = Vector{Float64}(nrow(df))\n    \n    for i in 1:nrow(df)\n        compiled(row_vec, scenario.data, i)\n        policy_outcomes[i] = row_vec[1]  # Or some welfare function\n    end\n    \n    welfare_results[policy_name] = policy_outcomes\nend\n\n# Compare distributions\nfor (policy, outcomes) in welfare_results\n    println(\"Policy: $policy\")\n    println(\"  Mean outcome: $(mean(outcomes))\")\n    println(\"  Std outcome: $(std(outcomes))\")  \n    println(\"  Gini coefficient: $(gini_coefficient(outcomes))\")\nend","category":"page"},{"location":"guide/scenarios/#Sensitivity-Analysis","page":"Scenario Analysis","title":"Sensitivity Analysis","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"# Analyze sensitivity to key parameters\nfunction sensitivity_analysis(compiled, data, base_individual, param_ranges)\n    base_scenario = create_scenario(\"base\", data)\n    results = Dict{Symbol, Vector{Tuple{Float64, Float64}}}()\n    \n    for (param, range) in param_ranges\n        param_results = Vector{Tuple{Float64, Float64}}()\n        \n        for value in range\n            # Create scenario with this parameter value\n            set_override!(base_scenario, param, value)\n            \n            # Evaluate\n            row_vec = Vector{Float64}(undef, length(compiled))\n            compiled(row_vec, base_scenario.data, base_individual)\n            \n            push!(param_results, (value, row_vec[1]))\n        end\n        \n        results[param] = param_results\n        remove_override!(base_scenario, param)  # Reset for next parameter\n    end\n    \n    return results\nend\n\n# Run sensitivity analysis\nsensitivity_ranges = Dict(\n    :age => 20:5:80,\n    :income => 20000:10000:100000,\n    :x => -3:0.5:3\n)\n\nsensitivity_results = sensitivity_analysis(compiled, data, 1, sensitivity_ranges)\n\n# Plot or analyze results\nfor (param, results) in sensitivity_results\n    values = [r[1] for r in results]\n    outcomes = [r[2] for r in results]\n    \n    println(\"Parameter: $param\")\n    println(\"  Range: $(minimum(values)) to $(maximum(values))\")\n    println(\"  Outcome range: $(minimum(outcomes)) to $(maximum(outcomes))\")\nend","category":"page"},{"location":"guide/scenarios/#Memory-Efficiency","page":"Scenario Analysis","title":"Memory Efficiency","text":"","category":"section"},{"location":"guide/scenarios/#Understanding-OverrideVector","page":"Scenario Analysis","title":"Understanding OverrideVector","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"# Compare memory usage\nn_obs = 1_000_000\n\n# Traditional approach: full vector\nfull_vector = fill(42.0, n_obs)\nprintln(\"Full vector size: $(sizeof(full_vector)) bytes\")\n\n# OverrideVector approach  \noverride_vector = OverrideVector(42.0, n_obs)\nprintln(\"Override vector size: $(sizeof(override_vector)) bytes\")\n\n# Memory savings\nsavings_ratio = sizeof(full_vector) / sizeof(override_vector)\nprintln(\"Memory savings: $(round(savings_ratio))x\")\n\n# Both provide same interface\n@assert full_vector[500_000] == override_vector[500_000]\n@assert length(full_vector) == length(override_vector)","category":"page"},{"location":"guide/scenarios/#Efficient-Scenario-Storage","page":"Scenario Analysis","title":"Efficient Scenario Storage","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"# Multiple scenarios with shared base data\nshared_data = Tables.columntable(df)\n\n# Each scenario only stores its overrides\nscenario1 = create_scenario(\"s1\", shared_data; treatment = true)\nscenario2 = create_scenario(\"s2\", shared_data; income = 50000)  \nscenario3 = create_scenario(\"s3\", shared_data; age = 30, treatment = false)\n\n# Total memory is much less than 3 full copies of data\ntotal_scenario_memory = sizeof(scenario1) + sizeof(scenario2) + sizeof(scenario3)\nfull_data_memory = 3 * sum(sizeof(col) for col in shared_data)\n\nprintln(\"Scenario memory: $total_scenario_memory bytes\")\nprintln(\"Full copy memory: $full_data_memory bytes\")\nprintln(\"Savings: $(round(full_data_memory / total_scenario_memory))x\")","category":"page"},{"location":"guide/scenarios/#Best-Practices","page":"Scenario Analysis","title":"Best Practices","text":"","category":"section"},{"location":"guide/scenarios/#Scenario-Design","page":"Scenario Analysis","title":"Scenario Design","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"Use descriptive names for scenarios\nGroup related scenarios in collections\nCache compiled formulas when evaluating many scenarios\nPre-allocate output vectors for repeated evaluations","category":"page"},{"location":"guide/scenarios/#Performance-Tips","page":"Scenario Analysis","title":"Performance Tips","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"Create scenarios once and reuse them\nUse batch evaluation for multiple individuals\nConsider using views for large result matrices\nProfile memory usage in complex scenario analyses","category":"page"},{"location":"guide/scenarios/#Statistical-Considerations","page":"Scenario Analysis","title":"Statistical Considerations","text":"","category":"section"},{"location":"guide/scenarios/","page":"Scenario Analysis","title":"Scenario Analysis","text":"Always compare to appropriate baselines\nAccount for uncertainty in treatment effect estimates\nConsider interaction effects in scenario design","category":"page"},{"location":"architecture/#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Technical overview of FormulaCompiler.jl’s unified, zero‑allocation compilation and execution model.","category":"page"},{"location":"architecture/#Design-Philosophy","page":"Architecture","title":"Design Philosophy","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Move expensive work to compile time; keep runtime simple and type‑stable.","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Compile‑time specialization: All positions and operations are baked into types\nType stability: No dynamic dispatch in hot paths\nMemory reuse: Preallocate once; reuse across evaluations\nPosition mapping: Address everything by compile‑time positions, not names","category":"page"},{"location":"architecture/#System-Overview","page":"Architecture","title":"System Overview","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"(Image: Diagram)","category":"page"},{"location":"architecture/#Unified-Compilation-Pipeline","page":"Architecture","title":"Unified Compilation Pipeline","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"The compilation process transforms statistical formulas into optimized evaluators:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"(Image: Diagram)","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Compilation produces a single position‑mapped evaluator (UnifiedCompiled) in four steps:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Decompose terms → operations","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Parse the schema‑applied formula and convert into primitive ops:\nLoadOp, ConstantOp, UnaryOp, BinaryOp, ContrastOp, CopyOp","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Allocate positions","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Assign scratch positions for intermediates and indices for final outputs\nCache term → position mapping to reuse computed intermediates","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Specialize operation types","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Embed positions and keys as type parameters (e.g., LoadOp{:x, 3})\nConvert op vector to a tuple for type‑stable execution","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Package into UnifiedCompiled","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Store op tuple and a preallocated scratch buffer sized to maximum position\nProvide a callable that writes directly into a user‑supplied output vector","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Result: compiled(row_vec, data, row) runs at ~50ns with 0 allocations after warmup.","category":"page"},{"location":"architecture/#Operation-Set","page":"Architecture","title":"Operation Set","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Primitive operations form an acyclic execution plan:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"LoadOp{Column, OutPos}: data[column][row] → scratch[OutPos]\nConstantOp{Value, OutPos}: literal → scratch[OutPos]\nUnaryOp{Func, InPos, OutPos}: f(scratch[InPos]) → scratch[OutPos]\nBinaryOp{Func, In1, In2, OutPos}: f(scratch[In1], scratch[In2]) → scratch[OutPos]\nContrastOp{Column, OutPositions}: categorical expansion → scratch[each(OutPositions)]\nCopyOp{InPos, OutIdx}: scratch[InPos] → output[OutIdx]","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"All operation ordering respects dependencies to ensure each input is ready when used.","category":"page"},{"location":"architecture/#Zero‑Allocation-Execution","page":"Architecture","title":"Zero‑Allocation Execution","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Runtime evaluation is pure array indexing with concrete types:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Scratch: Vector{Float64}(undef, ScratchSize) allocated once inside UnifiedCompiled\nOutput: Provided by the caller; must have length length(compiled)\nExecution: Iterate the typed op tuple and update scratch/output in place","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Path to zero allocations:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Preallocate scratch once per compiled formula\nNo temporary arrays or dynamic dispatch during execution\nColumn access uses direct field lookup from a NamedTuple (column table)","category":"page"},{"location":"architecture/#Memory-and-Scenarios","page":"Architecture","title":"Memory & Scenarios","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"OverrideVector: Lazy constant vectors for scenario overrides (~32 bytes)\nDataScenario: Wraps a base dataset plus overrides without copying columns\ncreate_scenario_grid: Generate large scenario sets efficiently","category":"page"},{"location":"architecture/#Integration","page":"Architecture","title":"Integration","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"GLM.jl: Works with all linear and generalized linear models\nMixedModels.jl: Automatically extracts fixed‑effects formula via fixed_effects_form\nStandardizedPredictors.jl: ZScore standardization supported at compile time","category":"page"},{"location":"architecture/#Extensibility","page":"Architecture","title":"Extensibility","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Add an operation or transformation by composing existing ops during decomposition, or extend model support via dispatch that extracts a StatsModels @formula and delegates to the unified compiler.","category":"page"},{"location":"architecture/#Performance-Monitoring","page":"Architecture","title":"Performance Monitoring","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Check allocations and timings with BenchmarkTools:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"@allocated compiled(row_vec, data, 1)  # Expect 0\n@benchmark $compiled($row_vec, $data, 1)","category":"page"},{"location":"architecture/#Future-Directions","page":"Architecture","title":"Future Directions","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Parallel row evaluation for batches\nExpanded function library and transformations\nAD‑friendly derivatives and sensitivity analysis\nStreaming and distributed execution patterns","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete API reference for FormulaCompiler.jl functions and types.","category":"page"},{"location":"api/#Core-Compilation-Functions","page":"API Reference","title":"Core Compilation Functions","text":"","category":"section"},{"location":"api/#FormulaCompiler.compile_formula","page":"API Reference","title":"FormulaCompiler.compile_formula","text":"compile_formula(model, data_example::NamedTuple) -> UnifiedCompiled\n\nPrimary API for compiling statistical models into high-performance evaluators.\n\nPosition Mapping System\n\nThis function implements a position mapping system that converts statistical  formulas into zero-allocation execution plans. The system works in three phases:\n\nPhase 1: Formula Decomposition\n\nExtracts the schema-applied formula from the fitted model\nConverts StatsModels terms into typed operations (LoadOp, ConstantOp, etc.)\nAssigns unique scratch positions to intermediate values and output positions to final results\n\nPhase 2: Position Allocation\n\nUses CompilationContext.position_map to track term → position mappings\nAllocates consecutive scratch positions starting from 1\nMaps each model matrix column to a specific output position\n\nPhase 3: Type Specialization\n\nEmbeds all positions as compile-time type parameters\nCreates operations like LoadOp{:x, 3}() (load column :x into scratch position 3)\nEnables zero-allocation execution through complete type specialization\n\nPosition Mapping Examples\n\n# Simple formula: y ~ 1 + x\n# Position mapping:\n# scratch[1] = 1.0          (intercept, ConstantOp{1.0, 1})\n# scratch[2] = data.x[row]  (variable x, LoadOp{:x, 2})  \n# output[1] = scratch[1]    (CopyOp{1, 1})\n# output[2] = scratch[2]    (CopyOp{2, 2})\n\n# Interaction: y ~ x * z  \n# Position mapping:\n# scratch[1] = data.x[row]     (LoadOp{:x, 1})\n# scratch[2] = data.z[row]     (LoadOp{:z, 2}) \n# scratch[3] = scratch[1] * scratch[2]  (BinaryOp{:*, 1, 2, 3})\n# output[1] = scratch[1], output[2] = scratch[2], output[3] = scratch[3]\n\n# Function: y ~ log(x)\n# Position mapping:\n# scratch[1] = data.x[row]     (LoadOp{:x, 1})\n# scratch[2] = log(scratch[1]) (UnaryOp{:log, 1, 2})\n# output[1] = scratch[2]       (CopyOp{2, 1})\n\nPerformance Characteristics\n\nScratch space: Fixed size allocated once, reused for all rows\nType stability: All positions known at compile time → zero allocations\nExecution: Pure array indexing with no dynamic dispatch\nMemory: O(maxscratchpositions) + O(output_size) per formula\n\nArguments\n\nmodel: Fitted statistical model (GLM, LMM, etc.) with schema-applied formula  \ndata_example: NamedTuple with sample data for type inference and schema validation\n\nReturns\n\nUnifiedCompiled{T, OpsTuple, ScratchSize, OutputSize} containing:\n\nType-specialized operation tuple\nPre-allocated scratch buffer  \nPosition mappings embedded in operation types\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-Row-Evaluation","page":"API Reference","title":"Model Row Evaluation","text":"","category":"section"},{"location":"api/#FormulaCompiler.modelrow","page":"API Reference","title":"FormulaCompiler.modelrow","text":"modelrow(model, data, row_idx) -> Vector{Float64}\n\nEvaluate a single row and return a new vector (allocating version). Uses compiled formulas for optimal performance.\n\nExample\n\nrow_values = modelrow(model, data, 1)  # Returns Vector{Float64}\n\n\n\n\n\nmodelrow(model, data, row_indices) -> Matrix{Float64}\n\nEvaluate multiple rows and return a new matrix (allocating version). Uses compiled formulas for optimal performance.\n\nExample\n\nmatrix = modelrow(model, data, [1, 5, 10])  # Returns Matrix{Float64}\n\n\n\n\n\nmodelrow(compiled_formula, data, row_idx) -> Vector{Float64}\n\nEvaluate a single row with pre-compiled compiled formula.\n\nExample\n\ncompiled = compile_formula(model, data)\nrow_values = modelrow(compiled, data, 1)  # Returns Vector{Float64}\n\n\n\n\n\nmodelrow(compiled_formula, data, row_indices) -> Matrix{Float64}\n\nEvaluate multiple rows with pre-compiled compiled formula.\n\nExample\n\ncompiled = compile_formula(model, data)\nmatrix = modelrow(compiled, data, [1, 5, 10])  # Returns Matrix{Float64}\n\n\n\n\n\nmodelrow(model, scenario::DataScenario, row_idx) -> Vector{Float64}\n\nEvaluate model row using a data scenario (allocating version).\n\n\n\n\n\nmodelrow(compiled::UnifiedCompiled, scenario::DataScenario, row_idx) -> Vector{Float64}\n\nEvaluate model row using a data scenario with UnifiedCompiled (allocating version).\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.modelrow!","page":"API Reference","title":"FormulaCompiler.modelrow!","text":"modelrow!(row_vec, compiled_formula, data, row_idx)\n\nEvaluate a single row of the model matrix in-place (zero-allocation).\n\nArguments\n\nrow_vec::AbstractVector{Float64}: Pre-allocated output vector (modified in-place)\ncompiled_formula: Compiled formula from compile_formula\ndata: Data in Tables.jl format (preferably from Tables.columntable)\nrow_idx::Int: Row index to evaluate\n\nReturns\n\nrow_vec: The same vector passed in, now containing the evaluated row\n\nExample\n\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\nmodelrow!(row_vec, compiled, data, 1)  # Zero allocations\n\n\n\n\n\nmodelrow!(row_vec, model, data, row_idx; cache=true)\n\nEvaluate a single row of the model matrix in-place with automatic compilation.\n\nArguments\n\nrow_vec::AbstractVector{Float64}: Pre-allocated output vector (modified in-place)\nmodel: Statistical model (GLM, MixedModel, etc.)\ndata: Data in Tables.jl format\nrow_idx::Int: Row index to evaluate\ncache::Bool: Whether to cache compiled formula (default: true)\n\nReturns\n\nrow_vec: The same vector passed in, now containing the evaluated row\n\nExample\n\nmodel = lm(@formula(y ~ x + group), df)\ndata = Tables.columntable(df)\nrow_vec = Vector{Float64}(undef, size(modelmatrix(model), 2))\nmodelrow!(row_vec, model, data, 1)\n\nnote: Note\nFirst call compiles the formula. Subsequent calls reuse cached version when cache=true.\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.ModelRowEvaluator","page":"API Reference","title":"FormulaCompiler.ModelRowEvaluator","text":"ModelRowEvaluator{D, O}\n\nPre-compiled evaluator using compiled formulas only.\n\n\n\n\n\n","category":"type"},{"location":"api/#Override-and-Scenario-System","page":"API Reference","title":"Override and Scenario System","text":"","category":"section"},{"location":"api/#FormulaCompiler.OverrideVector","page":"API Reference","title":"FormulaCompiler.OverrideVector","text":"OverrideVector{T} <: AbstractVector{T}\n\nA lazy vector that returns the same override value for all indices. This avoids allocating full arrays when setting all observations to a representative value.\n\nExample\n\n# Instead of: fill(2.5, 1_000_000)  # Allocates 8MB\n# Use: OverrideVector(2.5, 1_000_000)  # Allocates ~32 bytes\n\n\n\n\n\n","category":"type"},{"location":"api/#FormulaCompiler.DataScenario","page":"API Reference","title":"FormulaCompiler.DataScenario","text":"DataScenario\n\nRepresents a data scenario with specific variable overrides. Contains the modified data that can be used directly with compiled formulas.\n\nFields\n\nname::String: Descriptive name for the scenario\noverrides::Dict{Symbol,Any}: Variable overrides (mutable for iterative development)  \ndata::NamedTuple: Modified column-table data with OverrideVectors applied\noriginal_data::NamedTuple: Original unmodified data for reference\n\n\n\n\n\n","category":"type"},{"location":"api/#FormulaCompiler.create_scenario","page":"API Reference","title":"FormulaCompiler.create_scenario","text":"create_scenario(name, original_data; overrides...)\ncreate_scenario(name, original_data, overrides::Dict)\n\nCreate a data scenario with specified variable overrides for counterfactual analysis.\n\nArguments\n\nname::String: Descriptive name for this scenario\noriginal_data::NamedTuple: Original data in column-table format (from Tables.columntable)\noverrides...: Keyword arguments for variable overrides (or Dict in second method)\n\nReturns\n\nDataScenario: Object containing original data, overrides, and modified data with OverrideVectors\n\nExample\n\ndata = Tables.columntable(df)\n\n# Override single variable to mean\nscenario1 = create_scenario(\"x_at_mean\", data; x = mean(data.x))\n\n# Override multiple variables for policy analysis\nscenario2 = create_scenario(\"policy\", data; x = 2.5, group = \"A\", treatment = true)\n\n# Use dictionary for dynamic overrides\noverrides = Dict(:dose => 100.0, :region => \"North\")\nscenario3 = create_scenario(\"high_dose_north\", data, overrides)\n\n# Evaluate with compiled formula (zero-allocation)\ncompiled = compile_formula(model)\nrow_vec = Vector{Float64}(undef, length(compiled))\ncompiled(row_vec, scenario1.data, row_idx)\n\nnote: Note\nUses memory-efficient OverrideVector to avoid data duplication. Each override creates a lazy vector returning the same value for all rows.\n\n\n\n\n\n","category":"function"},{"location":"api/#Near-Zero-Allocation-Derivatives","page":"API Reference","title":"Near-Zero-Allocation Derivatives","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"FormulaCompiler.jl provides a sophisticated automatic differentiation system that achieves near-theoretical optimal allocation performance through aggressive optimization.","category":"page"},{"location":"api/#Performance-Characteristics","page":"API Reference","title":"Performance Characteristics","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Core evaluation: Exactly 0 allocations  \nForwardDiff derivatives: ≤112 bytes per call (ForwardDiff internal minimum)\nMarginal effects: ≤256 bytes per call (optimized with preallocated buffers)\nAllocation efficiency: >99.75% compared to naive AD approaches\nValidation: Cross-validated against finite differences (rtol=1e-6, atol=1e-8)","category":"page"},{"location":"api/#FormulaCompiler.build_derivative_evaluator","page":"API Reference","title":"FormulaCompiler.build_derivative_evaluator","text":"build_derivative_evaluator(compiled, data; vars, chunk=:auto) -> DerivativeEvaluator\n\nBuild a ForwardDiff-based derivative evaluator for a fixed set of variables.\n\nArguments:\n\ncompiled::UnifiedCompiled: Result of compile_formula(model, data).\ndata::NamedTuple: Column-table data (e.g., Tables.columntable(df)).\nvars::Vector{Symbol}: Variables to differentiate with respect to (typically continuous predictors).\nchunk: ForwardDiff.Chunk{N}() or :auto (uses Chunk{length(vars)}).\n\nReturns:\n\nDerivativeEvaluator: Prebuilt evaluator object reusable across rows.\n\nNotes:\n\nCompile once per model + variable set; reuse across calls.\nZero allocations in steady state after warmup (typed closure + config; no per-call merges).\nKeep vars fixed for best specialization.\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.derivative_modelrow!","page":"API Reference","title":"FormulaCompiler.derivative_modelrow!","text":"derivative_modelrow!(J, deval, row) -> AbstractMatrix{Float64}\n\nFill J with the Jacobian of one model row with respect to deval.vars.\n\nArguments:\n\nJ::AbstractMatrix{Float64}: Preallocated buffer of size (n_terms, n_vars).\ndeval::DerivativeEvaluator: Built by build_derivative_evaluator.\nrow::Int: Row index (1-based).\n\nReturns:\n\nThe same J buffer, with J[i, j] = ∂X[i]/∂vars[j] for the given row.\n\nNotes:\n\nOrientation is (n_terms, n_vars); n_terms == length(compiled).\nSmall allocations (~368 bytes) due to ForwardDiff internals. For strict zero-allocation requirements, use derivative_modelrow_fd! instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.derivative_modelrow","page":"API Reference","title":"FormulaCompiler.derivative_modelrow","text":"derivative_modelrow(deval, row) -> Matrix{Float64}\n\nAllocating convenience wrapper that returns the Jacobian for one row.\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.derivative_modelrow_fd!","page":"API Reference","title":"FormulaCompiler.derivative_modelrow_fd!","text":"derivative_modelrow_fd!(J, compiled, data, row; vars, step=:auto)\n\nFinite-difference Jacobian for a single row using central differences (standalone).\n\nArguments:\n\nJ::AbstractMatrix{Float64}: Preallocated (n_terms, n_vars) buffer.\ncompiled::UnifiedCompiled: Result of compile_formula.\ndata::NamedTuple: Column-table data.\nrow::Int: Row index.\nvars::Vector{Symbol}: Variables to differentiate with respect to.\nstep: Numeric step size or :auto (eps()^(1/3) * max(1, |x|)).\n\nNotes:\n\nTwo evaluations per variable; useful as a robust fallback and for cross-checks.\nThis standalone path allocates per call (builds per-call overrides and small temporaries). For zero allocations after warmup, prefer the evaluator FD path (derivative_modelrow_fd_pos!).\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.contrast_modelrow!","page":"API Reference","title":"FormulaCompiler.contrast_modelrow!","text":"contrast_modelrow!(Δ, compiled, data, row; var, from, to)\n\nCompute a discrete contrast at one row for a single variable: Δ = X(to) − X(from).\n\nArguments:\n\nΔ::AbstractVector{Float64}: Preallocated buffer of length n_terms.\ncompiled::UnifiedCompiled: Result of compile_formula.\ndata::NamedTuple: Column-table data.\nrow::Int: Row index.\nvar::Symbol: Variable to change (e.g., :group3).\nfrom, to: Values to contrast (level names or CategoricalValue for categorical; numbers for discrete).\n\nNotes:\n\nUses a row-local override; for categorical columns, values are normalized to the column's levels.\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.continuous_variables","page":"API Reference","title":"FormulaCompiler.continuous_variables","text":"continuous_variables(compiled, data) -> Vector{Symbol}\n\nReturn a list of continuous variable symbols present in the compiled ops, excluding categoricals detected via ContrastOps. Filters by eltype(data[sym]) <: Real.\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.marginal_effects_eta!","page":"API Reference","title":"FormulaCompiler.marginal_effects_eta!","text":"marginal_effects_eta!(g, de, beta, row; backend=:ad)\n\nFill g with marginal effects of η = Xβ w.r.t. de.vars at row. Implements: g = J' * β, where J = ∂X/∂vars.\n\nArguments:\n\nbackend::Symbol: :ad (ForwardDiff) or :fd (finite differences)\n\nBackends and allocations:\n\n:ad: Uses ForwardDiff automatic differentiation. Small allocations (~368 bytes)  due to AD internals, but faster and more accurate.\n:fd: Uses zero-allocation finite differences. Strict 0 bytes after warmup, but slightly slower due to multiple function evaluations.\nAllocating convenience (marginal_effects_eta) allocates the result vector by design.\n\nRecommendations:\n\nUse :fd backend for strict zero-allocation requirements\nUse :ad backend for speed and numerical accuracy (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#FormulaCompiler.marginal_effects_mu!","page":"API Reference","title":"FormulaCompiler.marginal_effects_mu!","text":"marginal_effects_mu!(g, de, beta, row; link, backend=:ad)\n\nCompute marginal effects of μ = g⁻¹(η) at row via chain rule: dμ/dx = (dμ/dη) * (dη/dx).\n\nArguments:\n\nlink: Link function (e.g., IdentityLink(), LogLink(), LogitLink())\nbackend::Symbol: :ad (ForwardDiff) or :fd (finite differences)\n\nBackends and allocations:\n\n:ad: Uses ForwardDiff via η path. Small allocations (~368 bytes) due to AD internals, but faster and more accurate.\n:fd: Uses zero-allocation finite differences. Strict 0 bytes after warmup, but slightly slower due to multiple function evaluations.\nAllocating convenience (marginal_effects_mu) allocates the result vector by design.\n\nRecommendations:\n\nUse :fd backend for strict zero-allocation requirements\nUse :ad backend for speed and numerical accuracy (default)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#Function-Details","page":"API Reference","title":"Function Details","text":"","category":"section"},{"location":"api/#compile_formula(model,-data)-UnifiedCompiled","page":"API Reference","title":"compile_formula(model, data) -> UnifiedCompiled","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Compile a fitted model’s formula into a position-mapped, zero-allocation evaluator.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"model: Fitted statistical model (GLM, MixedModel, etc.)\ndata: Tables.jl-compatible data (prefer a column table via Tables.columntable)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"UnifiedCompiled: Type-specialized evaluator with embedded position mappings","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"model = lm(@formula(y ~ x + group), df)\ndata = Tables.columntable(df)\ncompiled = compile_formula(model, data)","category":"page"},{"location":"api/#modelrow(model,-data,-row_index)-Vector{Float64}","page":"API Reference","title":"modelrow(model, data, row_index) -> Vector{Float64}","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Evaluate model matrix row (allocating version).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"model: Fitted statistical model or compiled formula\ndata: Data in Tables.jl format\nrow_index: Row index to evaluate (Int) or indices (Vector{Int}/AbstractVector)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{Float64} or Matrix{Float64}: Model matrix row(s)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"row_vec = modelrow(model, data, 1)\nmultiple_rows = modelrow(model, data, [1, 5, 10])","category":"page"},{"location":"api/#modelrow!(output,-compiled,-data,-row_indices)","page":"API Reference","title":"modelrow!(output, compiled, data, row_indices)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"In-place model matrix row evaluation (zero-allocation).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"output: Pre-allocated output array (Vector or Matrix)\ncompiled: Compiled formula object\ndata: Data in Tables.jl format  \nrow_indices: Row index (Int) or indices (AbstractVector)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"compiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\nmodelrow!(row_vec, compiled, data, 1)  # Zero allocations\n\n# Multiple rows\nmatrix = Matrix{Float64}(undef, 10, length(compiled))\nmodelrow!(matrix, compiled, data, 1:10)","category":"page"},{"location":"api/#ModelRowEvaluator(model,-data)","page":"API Reference","title":"ModelRowEvaluator(model, data)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create a reusable model row evaluator object.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"model: Fitted statistical model\ndata: Data in DataFrame or Tables.jl format","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Methods:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"evaluator(row_index): Returns new vector (allocating)\nevaluator(output, row_index): In-place evaluation (non-allocating)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"evaluator = ModelRowEvaluator(model, df)\nresult = evaluator(1)  # Allocating\nevaluator(row_vec, 1)  # Non-allocating","category":"page"},{"location":"api/#create_scenario(name,-data;-overrides...)","page":"API Reference","title":"create_scenario(name, data; overrides...)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create a data scenario with variable overrides.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"name: Scenario name (String)\ndata: Base data in Tables.jl format\noverrides...: Keyword arguments specifying variable overrides","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"DataScenario: Scenario object with override data","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"scenario = create_scenario(\"treatment\", data; \n    treatment = true,\n    dose = 100.0\n)","category":"page"},{"location":"api/#create_scenario_grid(name,-data,-parameter_dict)","page":"API Reference","title":"create_scenario_grid(name, data, parameter_dict)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create all combinations of scenario parameters.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"name: Base name for scenarios\ndata: Base data\nparameter_dict: Dict mapping variables to vectors of values","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{DataScenario}: Vector of all parameter combinations","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"grid = create_scenario_grid(\"policy\", data, Dict(\n    :treatment => [false, true],\n    :dose => [50, 100, 150]\n))  # Creates 6 scenarios","category":"page"},{"location":"api/#OverrideVector(value,-length)","page":"API Reference","title":"OverrideVector(value, length)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create a memory-efficient constant vector.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"value: Constant value to return\nlength: Vector length","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"OverrideVector: Memory-efficient constant vector","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Traditional: 8MB for 1M elements\ntraditional = fill(42.0, 1_000_000)\n\n# OverrideVector: ~32 bytes\nefficient = OverrideVector(42.0, 1_000_000)\n\n# Same interface\n@assert traditional[500_000] == efficient[500_000]","category":"page"},{"location":"api/#Scenario-Management-Functions","page":"API Reference","title":"Scenario Management Functions","text":"","category":"section"},{"location":"api/#set_override!(scenario,-variable,-value)","page":"API Reference","title":"set_override!(scenario, variable, value)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Add or update a variable override in a scenario.","category":"page"},{"location":"api/#remove_override!(scenario,-variable)","page":"API Reference","title":"remove_override!(scenario, variable)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Remove a variable override from a scenario.","category":"page"},{"location":"api/#update_scenario!(scenario;-overrides...)","page":"API Reference","title":"update_scenario!(scenario; overrides...)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Bulk update multiple overrides in a scenario.","category":"page"},{"location":"api/#get_overrides(scenario)","page":"API Reference","title":"get_overrides(scenario)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get dictionary of current overrides in a scenario.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"scenario = create_scenario(\"dynamic\", data)\nset_override!(scenario, :x, 1.0)\nupdate_scenario!(scenario; y = 2.0, z = 3.0)\noverrides = get_overrides(scenario)  # Dict(:x => 1.0, :y => 2.0, :z => 3.0)\nremove_override!(scenario, :z)","category":"page"},{"location":"api/#Integration-Functions","page":"API Reference","title":"Integration Functions","text":"","category":"section"},{"location":"api/#fixed_effects_form(mixed_model)","page":"API Reference","title":"fixed_effects_form(mixed_model)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Extract fixed effects formula from a MixedModel.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"mixed_model: Fitted MixedModel","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"FormulaTerm: Fixed effects portion of the formula","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"mixed = fit(MixedModel, @formula(y ~ x + (1|group)), df)\nfixed_form = fixed_effects_form(mixed)  # Returns: y ~ x","category":"page"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#length(compiled_formula)","page":"API Reference","title":"length(compiled_formula)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get the number of terms in compiled formula (model matrix columns).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"compiled = compile_formula(model, data)\nn_terms = length(compiled)           # e.g., 4","category":"page"},{"location":"api/#Type-System","page":"API Reference","title":"Type System","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"UnifiedCompiled: Position-mapped, zero-allocation compiled evaluator\nDataScenario: Scenario with variable overrides\nScenarioCollection: Collection of related scenarios\nOverrideVector{T}: Memory-efficient constant vector\nModelRowEvaluator: Reusable evaluator object","category":"page"},{"location":"api/#Internal-Types","page":"API Reference","title":"Internal Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Operation types used by the unified compiler:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"LoadOp{Column, OutPos}: Load a data column into a scratch position\nConstantOp{Value, OutPos}: Place a compile-time constant into scratch\nUnaryOp{Func, InPos, OutPos}: Apply a unary function\nBinaryOp{Func, InPos1, InPos2, OutPos}: Apply a binary operation\nContrastOp{Column, OutPositions}: Expand a categorical column via contrasts\nCopyOp{InPos, OutIdx}: Copy from scratch to final output index","category":"page"},{"location":"api/#build_derivative_evaluator(compiled,-data;-vars,-chunk:auto)","page":"API Reference","title":"build_derivative_evaluator(compiled, data; vars, chunk=:auto)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Build a reusable ForwardDiff-based derivative evaluator for computing Jacobians and marginal effects.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"compiled: Compiled formula from compile_formula\ndata: Tables.jl-compatible data (column table preferred)\nvars: Vector of symbols for variables to differentiate with respect to\nchunk: ForwardDiff chunk size (:auto uses length(vars))","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"DerivativeEvaluator: Reusable evaluator with preallocated buffers","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Performance:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"One-time construction cost, then ~112 bytes per derivative call\nContains preallocated Jacobian matrices and gradient vectors","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"compiled = compile_formula(model, data)\nvars = continuous_variables(compiled, data)  # or [:x, :z]\nde = build_derivative_evaluator(compiled, data; vars=vars)","category":"page"},{"location":"api/#derivative_modelrow!(J,-evaluator,-row)","page":"API Reference","title":"derivative_modelrow!(J, evaluator, row)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Fill Jacobian matrix with derivatives of model row with respect to selected variables.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"J: Pre-allocated matrix of size (length(compiled), length(vars))\nevaluator: DerivativeEvaluator from build_derivative_evaluator\nrow: Row index to evaluate","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Performance:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"~112 bytes allocated per call (ForwardDiff internals)\nUses preallocated buffers for near-optimal efficiency","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"J = Matrix{Float64}(undef, length(compiled), length(de.vars))\nderivative_modelrow!(J, de, 1)  # Fill J with derivatives","category":"page"},{"location":"api/#marginal_effects_eta!(g,-evaluator,-beta,-row)","page":"API Reference","title":"marginal_effects_eta!(g, evaluator, beta, row)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Compute marginal effects on linear predictor η = Xβ using chain rule.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"g: Pre-allocated gradient vector of length length(vars)\nevaluator: DerivativeEvaluator \nbeta: Model coefficients vector\nrow: Row index","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Implementation:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Computes g = J' * β where J is the Jacobian matrix\nUses preallocated internal Jacobian buffer","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Performance:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"~112 bytes per call with preallocated buffers","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"β = coef(model)\ng = Vector{Float64}(undef, length(de.vars))\nmarginal_effects_eta!(g, de, β, 1)","category":"page"},{"location":"api/#marginal_effects_mu!(g,-evaluator,-beta,-row;-link)","page":"API Reference","title":"marginal_effects_mu!(g, evaluator, beta, row; link)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Compute marginal effects on mean μ via chain rule: dμ/dx = (dμ/dη) × (dη/dx).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"g: Pre-allocated gradient vector \nevaluator: DerivativeEvaluator\nbeta: Model coefficients\nrow: Row index\nlink: GLM link function (e.g., LogitLink(), LogLink())","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Supported Links:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"IdentityLink(), LogLink(), LogitLink(), ProbitLink()\nCloglogLink(), CauchitLink(), InverseLink(), SqrtLink()\nInverseSquareLink() (when available)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Performance:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"~112-256 bytes per call with preallocated internal buffers","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using GLM\nmarginal_effects_mu!(g, de, β, 1; link=LogitLink())","category":"page"},{"location":"api/#continuous_variables(compiled,-data)","page":"API Reference","title":"continuous_variables(compiled, data)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Extract continuous variable names from compiled operations, excluding categoricals.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"compiled: Compiled formula\ndata: Data used in compilation","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{Symbol}: Sorted list of continuous variable symbols","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"vars = continuous_variables(compiled, data)  # e.g., [:x, :z, :age]\nde = build_derivative_evaluator(compiled, data; vars=vars)","category":"page"},{"location":"api/#Performance-Notes","page":"API Reference","title":"Performance Notes","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Core functions (modelrow!, compiled(row_vec, data, row)) achieve exactly 0 bytes allocated\nDerivative functions achieve ~112 bytes per call (near-theoretical minimum for ForwardDiff)\nMarginal effects use preallocated buffers to minimize allocations (~112-256 bytes)\ncompile_formula has one-time compilation cost but enables many fast evaluations\nUse Tables.columntable format for best performance\nPre-allocate output vectors/matrices and reuse them across evaluations\nBuild derivative evaluators once and reuse across many calls","category":"page"},{"location":"guide/basic_usage/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"This page covers the core functionality of FormulaCompiler.jl with practical examples.","category":"page"},{"location":"guide/basic_usage/#Core-Interfaces","page":"Basic Usage","title":"Core Interfaces","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"FormulaCompiler.jl provides three main interfaces for different use cases:","category":"page"},{"location":"guide/basic_usage/#1.-Zero-Allocation-Interface-(Fastest)","page":"Basic Usage","title":"1. Zero-Allocation Interface (Fastest)","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"This is the primary interface for performance-critical applications:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using FormulaCompiler, GLM, DataFrames, Tables\n\n# Setup\ndf = DataFrame(x = randn(1000), y = randn(1000), group = rand([\"A\", \"B\"], 1000))\nmodel = lm(@formula(y ~ x * group), df)\ndata = Tables.columntable(df)\n\n# Compile once\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\n# Use many times (zero allocations)\ncompiled(row_vec, data, 1)    # ~50ns, 0 allocations\ncompiled(row_vec, data, 100)  # ~50ns, 0 allocations","category":"page"},{"location":"guide/basic_usage/#2.-Convenient-Interface-(Allocating)","page":"Basic Usage","title":"2. Convenient Interface (Allocating)","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"For quick prototyping or when allocation isn't critical:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Single row (returns new vector)\nrow_1 = modelrow(model, data, 1)\n\n# Multiple rows (returns matrix)\nrows_subset = modelrow(model, data, [1, 10, 50, 100])\n\n# Range of rows\nrows_range = modelrow(model, data, 1:10)","category":"page"},{"location":"guide/basic_usage/#3.-Object-Based-Interface","page":"Basic Usage","title":"3. Object-Based Interface","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Create a reusable evaluator object:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"evaluator = ModelRowEvaluator(model, df)\n\n# Allocating version\nresult = evaluator(1)\n\n# Zero-allocation version\nrow_vec = Vector{Float64}(undef, length(evaluator))\nevaluator(row_vec, 1)","category":"page"},{"location":"guide/basic_usage/#Understanding-the-Compiled-Object","page":"Basic Usage","title":"Understanding the Compiled Object","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Compiled formulas contain important information:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"compiled = compile_formula(model, data)\n\n# Number of terms in the model matrix (columns)\nlength(compiled)  # e.g., 4 for intercept + x + group_B + x:group_B\n\n# You can call it like a function\nrow_vec = Vector{Float64}(undef, length(compiled))\ncompiled(row_vec, data, row_index)","category":"page"},{"location":"guide/basic_usage/#Batch-Operations","page":"Basic Usage","title":"Batch Operations","text":"","category":"section"},{"location":"guide/basic_usage/#Multiple-Row-Evaluation","page":"Basic Usage","title":"Multiple Row Evaluation","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Pre-allocate matrix for multiple rows\nn_rows = 100\nmatrix = Matrix{Float64}(undef, n_rows, length(compiled))\n\n# Evaluate multiple rows efficiently\nmodelrow!(matrix, compiled, data, 1:n_rows)\n\n# Or specific rows\nspecific_rows = [1, 5, 10, 50, 100]\nmatrix_subset = Matrix{Float64}(undef, length(specific_rows), length(compiled))\nmodelrow!(matrix_subset, compiled, data, specific_rows)","category":"page"},{"location":"guide/basic_usage/#Working-with-Views","page":"Basic Usage","title":"Working with Views","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"For memory efficiency, you can work with matrix views:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"big_matrix = Matrix{Float64}(undef, 1000, length(compiled))\n\n# Fill specific rows using views\nfor i in 1:10\n    row_view = view(big_matrix, i, :)\n    compiled(row_view, data, i)\nend","category":"page"},{"location":"guide/basic_usage/#Data-Format-Considerations","page":"Basic Usage","title":"Data Format Considerations","text":"","category":"section"},{"location":"guide/basic_usage/#Column-Tables-(Recommended)","page":"Basic Usage","title":"Column Tables (Recommended)","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"For best performance, convert DataFrames to column tables:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Convert once, reuse many times\ndata = Tables.columntable(df)\ncompiled = compile_formula(model, data)","category":"page"},{"location":"guide/basic_usage/#Working-with-DataFrames-Directly","page":"Basic Usage","title":"Working with DataFrames Directly","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"You can work with DataFrames, but column tables are more efficient:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# This works but is slower\ncompiled = compile_formula(model, df)\ncompiled(row_vec, df, 1)\n\n# This is faster\ndata = Tables.columntable(df)\ncompiled = compile_formula(model, data)\ncompiled(row_vec, data, 1)","category":"page"},{"location":"guide/basic_usage/#Supported-Formula-Features","page":"Basic Usage","title":"Supported Formula Features","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"FormulaCompiler.jl handles all standard StatsModels.jl formula syntax:","category":"page"},{"location":"guide/basic_usage/#Basic-Terms","page":"Basic Usage","title":"Basic Terms","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Continuous variables\n@formula(y ~ x + z)\n\n# Transformations\n@formula(y ~ log(x) + sqrt(z) + x^2)\n\n# Boolean conditions\n@formula(y ~ (x > 0) + (z < mean(z)))","category":"page"},{"location":"guide/basic_usage/#Categorical-Variables","page":"Basic Usage","title":"Categorical Variables","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using CategoricalArrays\n\ndf.group = categorical(df.group)\n@formula(y ~ x + group)  # Automatic contrast coding","category":"page"},{"location":"guide/basic_usage/#Interactions","page":"Basic Usage","title":"Interactions","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Two-way interactions\n@formula(y ~ x * group)  # Expands to: x + group + x:group\n\n# Three-way interactions\n@formula(y ~ x * y * z)\n\n# Function interactions\n@formula(y ~ log(x) * group)","category":"page"},{"location":"guide/basic_usage/#Complex-Formulas","page":"Basic Usage","title":"Complex Formulas","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"@formula(y ~ x * group + log(z) * treatment + sqrt(abs(w)) + (x > mean(x)))","category":"page"},{"location":"guide/basic_usage/#Error-Handling","page":"Basic Usage","title":"Error Handling","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"FormulaCompiler.jl provides clear error messages:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Invalid row index\ntry\n    compiled(row_vec, data, 1001)  # Only 1000 rows\ncatch BoundsError\n    println(\"Row index out of bounds\")\nend\n\n# Mismatched output vector size\ntry\n    wrong_size = Vector{Float64}(undef, 3)  # Should be length(compiled)\n    compiled(wrong_size, data, 1)\ncatch DimensionMismatch\n    println(\"Output vector has wrong size\")\nend","category":"page"},{"location":"guide/basic_usage/#Memory-Management","page":"Basic Usage","title":"Memory Management","text":"","category":"section"},{"location":"guide/basic_usage/#Pre-allocation-Best-Practices","page":"Basic Usage","title":"Pre-allocation Best Practices","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Good: Pre-allocate and reuse\nrow_vec = Vector{Float64}(undef, length(compiled))\nfor i in 1:1000\n    compiled(row_vec, data, i)\n    # Process row_vec...\nend\n\n# Bad: Allocate each time\nfor i in 1:1000\n    row_vec = modelrow(model, data, i)  # Allocates!\n    # Process row_vec...\nend","category":"page"},{"location":"guide/basic_usage/#Large-Dataset-Considerations","page":"Basic Usage","title":"Large Dataset Considerations","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# For very large datasets, process in chunks\nchunk_size = 1000\nn_chunks = div(nrow(df), chunk_size)\n\nresults = Matrix{Float64}(undef, nrow(df), length(compiled))\n\nfor chunk in 1:n_chunks\n    start_idx = (chunk - 1) * chunk_size + 1\n    end_idx = min(chunk * chunk_size, nrow(df))\n    \n    chunk_results = view(results, start_idx:end_idx, :)\n    modelrow!(chunk_results, compiled, data, start_idx:end_idx)\nend","category":"page"},{"location":"guide/basic_usage/#Integration-with-Other-Packages","page":"Basic Usage","title":"Integration with Other Packages","text":"","category":"section"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"FormulaCompiler.jl works seamlessly with the Julia statistical ecosystem:","category":"page"},{"location":"guide/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using GLM, MixedModels, StandardizedPredictors\n\n# GLM models\nglm_model = glm(@formula(y ~ x), df, Normal(), IdentityLink())\ncompiled_glm = compile_formula(glm_model, data)\n\n# Mixed models (extracts fixed effects only)\nmixed_model = fit(MixedModel, @formula(y ~ x + (1|group)), df)\ncompiled_mixed = compile_formula(mixed_model, data)\n\n# Standardized predictors\ncontrasts = Dict(:x => ZScore())\nstd_model = lm(@formula(y ~ x), df, contrasts=contrasts)\ncompiled_std = compile_formula(std_model, data)","category":"page"},{"location":"integration/glm/#GLM.jl-Integration","page":"GLM.jl","title":"GLM.jl Integration","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"FormulaCompiler.jl seamlessly integrates with GLM.jl to provide zero-allocation model matrix evaluation for both linear and generalized linear models.","category":"page"},{"location":"integration/glm/#Supported-Models","page":"GLM.jl","title":"Supported Models","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"FormulaCompiler.jl works with all GLM.jl model types:","category":"page"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"Linear models (lm)\nGeneralized linear models (glm)\nAll distribution families and link functions\nCustom contrasts and standardized predictors","category":"page"},{"location":"integration/glm/#Basic-Usage","page":"GLM.jl","title":"Basic Usage","text":"","category":"section"},{"location":"integration/glm/#Linear-Models","page":"GLM.jl","title":"Linear Models","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"using GLM, FormulaCompiler, DataFrames, Tables\n\n# Create sample data\ndf = DataFrame(\n    y = randn(1000),\n    x1 = randn(1000),\n    x2 = randn(1000),\n    group = rand([\"A\", \"B\", \"C\"], 1000)\n)\n\n# Fit linear model\nmodel = lm(@formula(y ~ x1 + x2 * group), df)\n\n# Compile for zero-allocation evaluation\ndata = Tables.columntable(df)\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\n# Zero-allocation evaluation\ncompiled(row_vec, data, 1)  # ~50ns, 0 allocations","category":"page"},{"location":"integration/glm/#Generalized-Linear-Models","page":"GLM.jl","title":"Generalized Linear Models","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"using CategoricalArrays\n\n# Binary outcome data\ndf_binary = DataFrame(\n    success = rand(Bool, 1000),\n    x = randn(1000),\n    treatment = categorical(rand([\"control\", \"treatment\"], 1000)),\n    age = rand(20:80, 1000)\n)\n\n# Logistic regression\nlogit_model = glm(\n    @formula(success ~ x + treatment + age), \n    df_binary, \n    Binomial(), \n    LogitLink()\n)\n\n# Compile and use\ncompiled_logit = compile_formula(logit_model, Tables.columntable(df_binary))\nrow_vec = Vector{Float64}(undef, length(compiled_logit))\ncompiled_logit(row_vec, Tables.columntable(df_binary), 1)","category":"page"},{"location":"integration/glm/#Distribution-Families","page":"GLM.jl","title":"Distribution Families","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"FormulaCompiler.jl works with all GLM.jl distribution families:","category":"page"},{"location":"integration/glm/#Gaussian-(Normal)-Identity-Link","page":"GLM.jl","title":"Gaussian (Normal) - Identity Link","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"normal_model = glm(@formula(y ~ x1 + x2), df, Normal(), IdentityLink())\ncompiled_normal = compile_formula(normal_model, data)","category":"page"},{"location":"integration/glm/#Binomial-Logit-Link","page":"GLM.jl","title":"Binomial - Logit Link","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"# Logistic regression\nlogit_model = glm(@formula(success ~ x + age), df_binary, Binomial(), LogitLink())\n\n# Probit regression  \nprobit_model = glm(@formula(success ~ x + age), df_binary, Binomial(), ProbitLink())\n\n# Complementary log-log\ncloglog_model = glm(@formula(success ~ x + age), df_binary, Binomial(), CloglogLink())","category":"page"},{"location":"integration/glm/#Poisson-Log-Link","page":"GLM.jl","title":"Poisson - Log Link","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"# Count data\ndf_count = DataFrame(\n    count = rand(Poisson(2), 1000),\n    x = randn(1000),\n    exposure = rand(0.5:0.1:2.0, 1000)\n)\n\npoisson_model = glm(@formula(count ~ x + log(exposure)), df_count, Poisson(), LogLink())\ncompiled_poisson = compile_formula(poisson_model, Tables.columntable(df_count))","category":"page"},{"location":"integration/glm/#Gamma-Inverse-Link","page":"GLM.jl","title":"Gamma - Inverse Link","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"# Positive continuous data\ndf_gamma = DataFrame(\n    response = rand(Gamma(2, 3), 1000),\n    x = randn(1000),\n    factor = rand([\"low\", \"high\"], 1000)\n)\n\ngamma_model = glm(@formula(response ~ x + factor), df_gamma, Gamma(), InverseLink())\ncompiled_gamma = compile_formula(gamma_model, Tables.columntable(df_gamma))","category":"page"},{"location":"integration/glm/#Advanced-GLM-Features","page":"GLM.jl","title":"Advanced GLM Features","text":"","category":"section"},{"location":"integration/glm/#Custom-Contrasts","page":"GLM.jl","title":"Custom Contrasts","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"using StatsModels\n\n# Define custom contrasts\ncontrasts_dict = Dict(\n    :treatment => DummyCoding(base=\"control\"),\n    :group => EffectsCoding(),\n    :region => HelmertCoding()\n)\n\n# Fit model with custom contrasts\ndf_contrasts = DataFrame(\n    y = randn(1000),\n    x = randn(1000),\n    treatment = categorical(rand([\"control\", \"low\", \"high\"], 1000)),\n    group = categorical(rand([\"A\", \"B\", \"C\", \"D\"], 1000)),\n    region = categorical(rand([\"North\", \"South\", \"East\", \"West\"], 1000))\n)\n\nmodel_contrasts = lm(\n    @formula(y ~ x + treatment + group + region), \n    df_contrasts, \n    contrasts = contrasts_dict\n)\n\ncompiled_contrasts = compile_formula(model_contrasts, Tables.columntable(df_contrasts))","category":"page"},{"location":"integration/glm/#Weights-and-Offsets","page":"GLM.jl","title":"Weights and Offsets","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"# Weighted regression\nweights = rand(0.5:0.1:2.0, 1000)\nweighted_model = lm(@formula(y ~ x1 + x2), df, wts=weights)\n\n# GLM with offset\ndf_offset = DataFrame(\n    y = rand(Poisson(2), 1000),\n    x = randn(1000),\n    offset_var = log.(rand(0.5:0.1:2.0, 1000))\n)\n\noffset_model = glm(\n    @formula(y ~ x + offset(offset_var)), \n    df_offset, \n    Poisson(), \n    LogLink()\n)\n\n# FormulaCompiler handles both\ncompiled_weighted = compile_formula(weighted_model, Tables.columntable(df))\ncompiled_offset = compile_formula(offset_model, Tables.columntable(df_offset))","category":"page"},{"location":"integration/glm/#Performance-Comparisons","page":"GLM.jl","title":"Performance Comparisons","text":"","category":"section"},{"location":"integration/glm/#Benchmark-Against-modelmatrix()","page":"GLM.jl","title":"Benchmark Against modelmatrix()","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"using BenchmarkTools\n\n# Setup\ndf = DataFrame(\n    y = randn(1000),\n    x1 = randn(1000), \n    x2 = randn(1000),\n    group = categorical(rand([\"A\", \"B\", \"C\"], 1000))\n)\n\nmodel = lm(@formula(y ~ x1 * x2 + group + log(abs(x1) + 1)), df)\ndata = Tables.columntable(df)\n\n# Traditional approach\nfunction traditional_single_row(model, row_idx)\n    mm = modelmatrix(model)\n    return mm[row_idx, :]\nend\n\n# FormulaCompiler approach\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\nfunction fc_single_row(compiled, data, row_vec, row_idx)\n    compiled(row_vec, data, row_idx)\n    return row_vec\nend\n\n# Benchmark comparison\nprintln(\"Traditional approach:\")\n@benchmark traditional_single_row($model, 1)\n\nprintln(\"\\nFormulaCompiler approach:\")\n@benchmark fc_single_row($compiled, $data, $row_vec, 1)\n\n# Expected results:\n# Traditional: ~10μs, 1 allocation\n# FormulaCompiler: ~50ns, 0 allocations (~200x speedup)","category":"page"},{"location":"integration/glm/#Large-Model-Performance","page":"GLM.jl","title":"Large Model Performance","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"# Create a large, complex model\nfunction create_large_model(n_obs=10000)\n    df = DataFrame(\n        y = randn(n_obs),\n        x1 = randn(n_obs),\n        x2 = randn(n_obs),\n        x3 = randn(n_obs),\n        x4 = randn(n_obs),\n        group1 = categorical(rand(1:10, n_obs)),\n        group2 = categorical(rand(1:5, n_obs)),\n        group3 = categorical(rand(1:3, n_obs))\n    )\n    \n    # Complex formula with interactions\n    formula = @formula(y ~ (x1 + x2 + x3 + x4) * (group1 + group2) + \n                          log(abs(x1) + 1) * group3 + \n                          sqrt(abs(x2) + 1) + \n                          x3^2 + \n                          (x4 > 0))\n    \n    model = lm(formula, df)\n    return model, df\nend\n\n# Test performance on large model\nlarge_model, large_df = create_large_model(10000)\nlarge_data = Tables.columntable(large_df)\nlarge_compiled = compile_formula(large_model, large_data)\n\nprintln(\"Large model performance:\")\nprintln(\"Model matrix size: \", size(modelmatrix(large_model)))\nprintln(\"Compilation time:\")\n@time compile_formula(large_model, large_data)\n\nprintln(\"Single row evaluation:\")\nrow_vec = Vector{Float64}(undef, length(large_compiled))\n@benchmark $large_compiled($row_vec, $large_data, 1)","category":"page"},{"location":"integration/glm/#Real-world-Applications","page":"GLM.jl","title":"Real-world Applications","text":"","category":"section"},{"location":"integration/glm/#Marginal-Effects-Calculation","page":"GLM.jl","title":"Marginal Effects Calculation","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"function calculate_marginal_effects(model, data, variable_col, delta=0.01)\n    compiled = compile_formula(model, data)\n    n_rows = Tables.rowcount(data)\n    \n    # Get original variable values\n    original_values = data[variable_col]\n    \n    # Create scenarios with perturbed values\n    perturbed_values = original_values .+ delta\n    perturbed_data = (; data..., variable_col => perturbed_values)\n    \n    row_vec_original = Vector{Float64}(undef, length(compiled))\n    row_vec_perturbed = Vector{Float64}(undef, length(compiled))\n    \n    marginal_effects = Matrix{Float64}(undef, n_rows, length(compiled))\n    \n    for i in 1:n_rows\n        # Original prediction\n        compiled(row_vec_original, data, i)\n        \n        # Perturbed prediction  \n        compiled(row_vec_perturbed, perturbed_data, i)\n        \n        # Marginal effect\n        marginal_effects[i, :] .= (row_vec_perturbed .- row_vec_original) ./ delta\n    end\n    \n    return marginal_effects\nend\n\n# Example usage\nmarginal_fx = calculate_marginal_effects(model, data, :x1)","category":"page"},{"location":"integration/glm/#Bootstrap-Confidence-Intervals","page":"GLM.jl","title":"Bootstrap Confidence Intervals","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"function bootstrap_glm_coefficients(model, data, n_bootstrap=1000)\n    compiled = compile_formula(model, data)\n    n_obs = Tables.rowcount(data)\n    n_coefs = length(compiled)\n    \n    # Get original response variable\n    y = data[Symbol(model.mf.f.lhs)]\n    \n    bootstrap_coefs = Matrix{Float64}(undef, n_bootstrap, n_coefs)\n    row_vec = Vector{Float64}(undef, n_coefs)\n    \n    for boot in 1:n_bootstrap\n        # Bootstrap sample\n        sample_idx = rand(1:n_obs, n_obs)\n        \n        # Create design matrix for bootstrap sample\n        X_boot = Matrix{Float64}(undef, n_obs, n_coefs)\n        y_boot = Vector{Float64}(undef, n_obs)\n        \n        for (i, idx) in enumerate(sample_idx)\n            compiled(row_vec, data, idx)\n            X_boot[i, :] .= row_vec\n            y_boot[i] = y[idx]\n        end\n        \n        # Fit bootstrap model (simplified OLS)\n        bootstrap_coefs[boot, :] = X_boot \\ y_boot\n    end\n    \n    return bootstrap_coefs\nend","category":"page"},{"location":"integration/glm/#Prediction-Intervals","page":"GLM.jl","title":"Prediction Intervals","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"function prediction_intervals(model, data, confidence_level=0.95)\n    compiled = compile_formula(model, data)\n    n_obs = Tables.rowcount(data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    # Get model coefficients and residual variance\n    coefs = coef(model)\n    σ² = deviance(model) / dof_residual(model)\n    \n    # Critical value\n    α = 1 - confidence_level\n    t_crit = quantile(TDist(dof_residual(model)), 1 - α/2)\n    \n    predictions = Vector{Float64}(undef, n_obs)\n    lower_bounds = Vector{Float64}(undef, n_obs)\n    upper_bounds = Vector{Float64}(undef, n_obs)\n    \n    for i in 1:n_obs\n        compiled(row_vec, data, i)\n        \n        # Point prediction\n        pred = dot(coefs, row_vec)\n        predictions[i] = pred\n        \n        # Prediction standard error\n        # SE = sqrt(σ² * (1 + x'(X'X)⁻¹x))\n        # Simplified for demonstration\n        se = sqrt(σ² * (1 + sum(row_vec.^2) / n_obs))\n        \n        # Confidence bounds\n        margin = t_crit * se\n        lower_bounds[i] = pred - margin\n        upper_bounds[i] = pred + margin\n    end\n    \n    return (predictions = predictions, lower = lower_bounds, upper = upper_bounds)\nend","category":"page"},{"location":"integration/glm/#Integration-Best-Practices","page":"GLM.jl","title":"Integration Best Practices","text":"","category":"section"},{"location":"integration/glm/#Model-Validation","page":"GLM.jl","title":"Model Validation","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"function validate_glm_integration(model, data)\n    compiled = compile_formula(model, data)\n    \n    # Compare first few rows with modelmatrix\n    mm = modelmatrix(model)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    for i in 1:min(10, size(mm, 1))\n        compiled(row_vec, data, i)\n        original_row = mm[i, :]\n        \n        if !isapprox(row_vec, original_row, rtol=1e-12)\n            @warn \"Mismatch in row $i\"\n            println(\"Original: \", original_row)\n            println(\"Compiled: \", row_vec)\n            return false\n        end\n    end\n    \n    println(\"✓ FormulaCompiler matches GLM.jl modelmatrix for all tested rows\")\n    return true\nend\n\n# Validate integration\nvalidate_glm_integration(model, data)","category":"page"},{"location":"integration/glm/#Memory-Usage-Comparison","page":"GLM.jl","title":"Memory Usage Comparison","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"function compare_memory_usage(model, data)\n    # Traditional approach\n    traditional_memory = @allocated modelmatrix(model)\n    \n    # FormulaCompiler approach\n    compilation_memory = @allocated compile_formula(model, data)\n    \n    compiled = compile_formula(model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    evaluation_memory = @allocated compiled(row_vec, data, 1)\n    \n    println(\"Memory Usage Comparison:\")\n    println(\"Traditional modelmatrix(): \", traditional_memory, \" bytes\")\n    println(\"FormulaCompiler compilation: \", compilation_memory, \" bytes\")\n    println(\"FormulaCompiler evaluation: \", evaluation_memory, \" bytes\")\n    \n    if evaluation_memory == 0\n        println(\"✓ Zero-allocation evaluation achieved\")\n    else\n        @warn \"Non-zero allocation detected in evaluation\"\n    end\nend\n\ncompare_memory_usage(model, data)","category":"page"},{"location":"integration/glm/#Troubleshooting","page":"GLM.jl","title":"Troubleshooting","text":"","category":"section"},{"location":"integration/glm/#Common-Issues","page":"GLM.jl","title":"Common Issues","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"Type instability: Ensure all variables have consistent types\nMissing values: Handle missing values before compilation\nCategorical levels: Ensure categorical variables have the same levels in test data\nFormula complexity: Very complex formulas may have longer compilation times","category":"page"},{"location":"integration/glm/#Debugging-Tools","page":"GLM.jl","title":"Debugging Tools","text":"","category":"section"},{"location":"integration/glm/","page":"GLM.jl","title":"GLM.jl","text":"# Check compilation success\nfunction debug_compilation(model, data)\n    try\n        compiled = compile_formula(model, data)\n        println(\"✓ Compilation successful\")\n        println(\"Formula length: \", length(compiled))\n        return compiled\n    catch e\n        @error \"Compilation failed\" exception = e\n        return nothing\n    end\nend\n\n# Performance diagnostics\nfunction diagnose_performance(model, data)\n    compiled = compile_formula(model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    # Check allocation\n    alloc = @allocated compiled(row_vec, data, 1)\n    if alloc > 0\n        @warn \"Non-zero allocation detected: $alloc bytes\"\n    end\n    \n    # Check timing\n    time_ns = @elapsed compiled(row_vec, data, 1) * 1e9\n    if time_ns > 1000  # > 1μs\n        @warn \"Evaluation slower than expected: $(round(time_ns))ns\"\n    end\n    \n    println(\"Performance: $(round(time_ns))ns, $(alloc) bytes\")\nend","category":"page"},{"location":"integration/standardized_predictors/#StandardizedPredictors.jl-Integration","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl Integration","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"FormulaCompiler.jl integrates with StandardizedPredictors.jl to handle standardized predictors efficiently in zero-allocation model evaluation.","category":"page"},{"location":"integration/standardized_predictors/#Supported-Standardizations","page":"StandardizedPredictors.jl","title":"Supported Standardizations","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"Currently, FormulaCompiler.jl supports:","category":"page"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"ZScore: Z-score standardization (mean=0, std=1)\nFuture versions will support additional standardizations","category":"page"},{"location":"integration/standardized_predictors/#Basic-Usage","page":"StandardizedPredictors.jl","title":"Basic Usage","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"using StandardizedPredictors, FormulaCompiler, GLM, DataFrames, Tables\n\n# Create sample data\ndf = DataFrame(\n    y = randn(1000),\n    x1 = randn(1000) * 5 .+ 10,  # Mean ≈ 10, std ≈ 5\n    x2 = randn(1000) * 2 .+ 3,   # Mean ≈ 3, std ≈ 2\n    group = rand([\"A\", \"B\", \"C\"], 1000)\n)\n\n# Define standardization contrasts\ncontrasts_dict = Dict(\n    :x1 => ZScore(),\n    :x2 => ZScore()\n)\n\n# Fit model with standardized predictors\nmodel = lm(@formula(y ~ x1 + x2 * group), df, contrasts=contrasts_dict)\n\n# Compile with built-in standardization\ndata = Tables.columntable(df)\ncompiled = compile_formula(model, data)","category":"page"},{"location":"integration/standardized_predictors/#ZScore-Standardization","page":"StandardizedPredictors.jl","title":"ZScore Standardization","text":"","category":"section"},{"location":"integration/standardized_predictors/#Automatic-Integration","page":"StandardizedPredictors.jl","title":"Automatic Integration","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"FormulaCompiler.jl automatically handles ZScore standardization:","category":"page"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"# The standardization parameters are built into the compiled formula\nprintln(\"Model includes standardization: \", has_standardization(compiled))\n\n# Evaluation automatically applies standardization\nrow_vec = Vector{Float64}(undef, length(compiled))\ncompiled(row_vec, data, 1)  # x1 and x2 are automatically standardized","category":"page"},{"location":"integration/standardized_predictors/#Manual-Standardization-Parameters","page":"StandardizedPredictors.jl","title":"Manual Standardization Parameters","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"You can access the standardization parameters:","category":"page"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"# Get standardization info\nstd_info = get_standardization_info(compiled)\nprintln(\"Standardized variables: \", keys(std_info))\n\nfor (var, params) in std_info\n    println(\"Variable $var: mean=$(params.mean), std=$(params.std)\")\nend","category":"page"},{"location":"integration/standardized_predictors/#Custom-Standardization-Values","page":"StandardizedPredictors.jl","title":"Custom Standardization Values","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"Override standardization parameters for specific scenarios:","category":"page"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"# Create scenario with custom standardization\ncustom_scenario = create_scenario(\"custom_std\", data;\n    x1 = 0.0,  # Will be standardized as (0.0 - mean_x1) / std_x1\n    x2 = 1.0   # Will be standardized as (1.0 - mean_x2) / std_x2\n)\n\n# The standardization is applied automatically\ncompiled(row_vec, custom_scenario.data, 1)","category":"page"},{"location":"integration/standardized_predictors/#Advanced-Examples","page":"StandardizedPredictors.jl","title":"Advanced Examples","text":"","category":"section"},{"location":"integration/standardized_predictors/#Marginal-Effects-with-Standardization","page":"StandardizedPredictors.jl","title":"Marginal Effects with Standardization","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"function marginal_effects_standardized(model, data, variable, delta=0.1)\n    compiled = compile_formula(model, data)\n    \n    # Get original values\n    original_values = data[variable]\n    \n    # Create perturbed values (in original scale)\n    perturbed_values = original_values .+ delta\n    perturbed_data = (; data..., variable => perturbed_values)\n    \n    row_vec_orig = Vector{Float64}(undef, length(compiled))\n    row_vec_pert = Vector{Float64}(undef, length(compiled))\n    \n    n_obs = Tables.rowcount(data)\n    marginal_effects = Vector{Float64}(undef, n_obs)\n    \n    for i in 1:n_obs\n        # Both evaluations will apply standardization automatically\n        compiled(row_vec_orig, data, i)\n        compiled(row_vec_pert, perturbed_data, i)\n        \n        # Calculate marginal effect (difference in standardized scale)\n        pred_orig = dot(coef(model), row_vec_orig)\n        pred_pert = dot(coef(model), row_vec_pert)\n        \n        marginal_effects[i] = (pred_pert - pred_orig) / delta\n    end\n    \n    return marginal_effects\nend\n\n# Calculate marginal effects for standardized x1\nme_x1 = marginal_effects_standardized(model, data, :x1)\nprintln(\"Mean marginal effect of x1: \", mean(me_x1))","category":"page"},{"location":"integration/standardized_predictors/#Policy-Analysis-with-Standardized-Predictors","page":"StandardizedPredictors.jl","title":"Policy Analysis with Standardized Predictors","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"function standardized_policy_analysis(model, base_data)\n    compiled = compile_formula(model, base_data)\n    \n    # Get original means and stds for interpretation\n    x1_mean = mean(base_data.x1)\n    x1_std = std(base_data.x1)\n    x2_mean = mean(base_data.x2) \n    x2_std = std(base_data.x2)\n    \n    # Create policy scenarios (in original scale)\n    scenarios = Dict(\n        \"baseline\" => create_scenario(\"baseline\", base_data),\n        \n        # Move everyone to +1 standard deviation\n        \"high_x1\" => create_scenario(\"high_x1\", base_data; \n            x1 = x1_mean + x1_std\n        ),\n        \n        # Move everyone to population mean\n        \"mean_values\" => create_scenario(\"mean_values\", base_data;\n            x1 = x1_mean,\n            x2 = x2_mean\n        ),\n        \n        # Extreme policy: +2 standard deviations\n        \"extreme_policy\" => create_scenario(\"extreme\", base_data;\n            x1 = x1_mean + 2 * x1_std,\n            x2 = x2_mean + 2 * x2_std\n        )\n    )\n    \n    # Evaluate scenarios\n    results = Dict{String, Vector{Float64}}()\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    for (name, scenario) in scenarios\n        n_obs = Tables.rowcount(scenario.data)\n        predictions = Vector{Float64}(undef, n_obs)\n        \n        for i in 1:n_obs\n            compiled(row_vec, scenario.data, i)\n            predictions[i] = dot(coef(model), row_vec)\n        end\n        \n        results[name] = predictions\n    end\n    \n    # Compare scenarios\n    for (name, preds) in results\n        println(\"Scenario $name:\")\n        println(\"  Mean prediction: $(round(mean(preds), digits=3))\")\n        println(\"  Std prediction: $(round(std(preds), digits=3))\")\n        \n        if name != \"baseline\"\n            baseline_mean = mean(results[\"baseline\"])\n            effect = mean(preds) - baseline_mean\n            println(\"  Effect vs baseline: $(round(effect, digits=3))\")\n        end\n        println()\n    end\n    \n    return results\nend\n\n# Run analysis\npolicy_results = standardized_policy_analysis(model, data)","category":"page"},{"location":"integration/standardized_predictors/#Interpretation-Helpers","page":"StandardizedPredictors.jl","title":"Interpretation Helpers","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"# Functions to help interpret standardized results\n\nfunction unstandardize_prediction(prediction, y_mean, y_std)\n    \"\"\"Convert prediction back to original scale\"\"\"\n    return prediction * y_std + y_mean\nend\n\nfunction standardized_effect_size(effect, y_std)\n    \"\"\"Convert effect to Cohen's d (standardized effect size)\"\"\"\n    return effect / y_std\nend\n\nfunction interpret_standardized_coef(coef_value, x_std, y_std)\n    \"\"\"Interpret standardized coefficient\"\"\"\n    # Effect of 1 standard deviation change in X on Y (in Y's standard deviation units)\n    return coef_value * (x_std / y_std)\nend\n\n# Example usage\nmodel_coefs = coef(model)\ny_std = std(df.y)\nx1_std = std(df.x1)\n\nx1_coef_interpretation = interpret_standardized_coef(model_coefs[2], x1_std, y_std)\nprintln(\"One std dev increase in x1 changes y by $(round(x1_coef_interpretation, digits=3)) std devs\")","category":"page"},{"location":"integration/standardized_predictors/#Performance-Considerations","page":"StandardizedPredictors.jl","title":"Performance Considerations","text":"","category":"section"},{"location":"integration/standardized_predictors/#Compilation-Overhead","page":"StandardizedPredictors.jl","title":"Compilation Overhead","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"using BenchmarkTools\n\n# Standardization adds minimal compilation overhead\n@benchmark compile_formula($model, $data)\n\n# Evaluation performance is identical to non-standardized models\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\n@benchmark $compiled($row_vec, $data, 1)  # Still ~50ns, 0 allocations","category":"page"},{"location":"integration/standardized_predictors/#Memory-Efficiency","page":"StandardizedPredictors.jl","title":"Memory Efficiency","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"# Standardization parameters are stored efficiently\nsizeof_standardized = sizeof(compiled)\nprintln(\"Compiled formula size with standardization: $sizeof_standardized bytes\")\n\n# Scenarios still provide memory benefits\nlarge_scenario = create_scenario(\"large\", data; x1 = 100.0)  # Large value\nprintln(\"Scenario with standardization: $(sizeof(large_scenario)) bytes\")","category":"page"},{"location":"integration/standardized_predictors/#Best-Practices","page":"StandardizedPredictors.jl","title":"Best Practices","text":"","category":"section"},{"location":"integration/standardized_predictors/#Variable-Selection-for-Standardization","page":"StandardizedPredictors.jl","title":"Variable Selection for Standardization","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"# Good candidates for standardization\ngood_candidates = [\n    :income,        # Often has wide range and skew\n    :age,           # Different scales across studies\n    :test_scores,   # For comparing across tests\n    :measurements   # Physical measurements with different units\n]\n\n# Usually don't standardize\ndont_standardize = [\n    :binary_vars,   # 0/1 variables\n    :count_vars,    # Poisson-distributed variables\n    :categorical,   # Categorical variables (use contrasts instead)\n    :percentages    # Already on 0-100 scale\n]\n\n# Example: selective standardization\nselective_contrasts = Dict(\n    :income => ZScore(),      # Standardize income\n    :age => ZScore(),         # Standardize age  \n    :treatment => DummyCoding(),  # Don't standardize binary treatment\n    :region => EffectsCoding()    # Use effects coding for categorical\n)\n\nmodel_selective = lm(@formula(y ~ income + age + treatment + region), df, \n                    contrasts = selective_contrasts)","category":"page"},{"location":"integration/standardized_predictors/#Scenario-Design-with-Standardization","page":"StandardizedPredictors.jl","title":"Scenario Design with Standardization","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"function create_meaningful_scenarios(base_data, model)\n    # Get standardization info to create interpretable scenarios\n    x1_mean = mean(base_data.x1)\n    x1_std = std(base_data.x1)\n    x2_mean = mean(base_data.x2)\n    x2_std = std(base_data.x2)\n    \n    scenarios = Dict(\n        # Baseline: typical individual\n        \"typical\" => create_scenario(\"typical\", base_data;\n            x1 = x1_mean,      # Average x1\n            x2 = x2_mean       # Average x2\n        ),\n        \n        # High achiever: +1 std dev on both\n        \"high_achiever\" => create_scenario(\"high\", base_data;\n            x1 = x1_mean + x1_std,\n            x2 = x2_mean + x2_std\n        ),\n        \n        # Low performer: -1 std dev on both\n        \"low_performer\" => create_scenario(\"low\", base_data;\n            x1 = x1_mean - x1_std,\n            x2 = x2_mean - x2_std\n        ),\n        \n        # Mixed profile: high x1, low x2\n        \"mixed_profile\" => create_scenario(\"mixed\", base_data;\n            x1 = x1_mean + x1_std,\n            x2 = x2_mean - x1_std\n        )\n    )\n    \n    return scenarios\nend\n\nmeaningful_scenarios = create_meaningful_scenarios(data, model)","category":"page"},{"location":"integration/standardized_predictors/#Validation-and-Diagnostics","page":"StandardizedPredictors.jl","title":"Validation and Diagnostics","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"function validate_standardization(model, data)\n    compiled = compile_formula(model, data)\n    \n    # Check that standardized variables have correct properties\n    # (This is a conceptual check - actual implementation would need model internals)\n    \n    # Verify evaluation works correctly\n    row_vec = Vector{Float64}(undef, length(compiled))\n    compiled(row_vec, data, 1)\n    \n    # Compare with manual standardization\n    manual_x1 = (data.x1[1] - mean(data.x1)) / std(data.x1)\n    manual_x2 = (data.x2[1] - mean(data.x2)) / std(data.x2)\n    \n    println(\"✓ Standardization validation completed\")\n    println(\"Manual x1 standardization: $(round(manual_x1, digits=3))\")\n    println(\"Manual x2 standardization: $(round(manual_x2, digits=3))\")\n    \n    return true\nend\n\nvalidate_standardization(model, data)","category":"page"},{"location":"integration/standardized_predictors/#Future-Extensions","page":"StandardizedPredictors.jl","title":"Future Extensions","text":"","category":"section"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"FormulaCompiler.jl plans to support additional StandardizedPredictors.jl features:","category":"page"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"CenterScale: Custom center and scale parameters\nMeanScale: Mean scaling\nUnitScale: Unit scaling  \nCustom transformations: User-defined standardization functions","category":"page"},{"location":"integration/standardized_predictors/","page":"StandardizedPredictors.jl","title":"StandardizedPredictors.jl","text":"These will follow the same zero-allocation principles and integrate seamlessly with the scenario system.","category":"page"},{"location":"guide/advanced_features/#Advanced-Features","page":"Advanced Features","title":"Advanced Features","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"FormulaCompiler.jl provides sophisticated features for advanced statistical computing scenarios.","category":"page"},{"location":"guide/advanced_features/#Memory-Efficient-Override-System","page":"Advanced Features","title":"Memory-Efficient Override System","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"The override system allows you to create \"what-if\" scenarios without duplicating data in memory.","category":"page"},{"location":"guide/advanced_features/#OverrideVector","page":"Advanced Features","title":"OverrideVector","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"The foundation of the scenario system is OverrideVector, which provides a memory-efficient constant vector:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using FormulaCompiler\n\n# Traditional approach: allocates 8MB for 1M rows\ntraditional = fill(42.0, 1_000_000)\n\n# FormulaCompiler: allocates ~32 bytes\nefficient = OverrideVector(42.0, 1_000_000)\n\n# Both provide identical interface\ntraditional[500_000] == efficient[500_000]  # true\nlength(efficient) == 1_000_000              # true\n\n# But massive memory savings\nsizeof(traditional) ÷ sizeof(efficient)  # ~250,000x smaller!","category":"page"},{"location":"guide/advanced_features/#Data-Scenarios","page":"Advanced Features","title":"Data Scenarios","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Create scenarios with variable overrides:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using DataFrames, Tables\n\ndf = DataFrame(\n    x = randn(1000),\n    y = randn(1000), \n    treatment = rand(Bool, 1000),\n    group = rand([\"A\", \"B\", \"C\"], 1000)\n)\n\ndata = Tables.columntable(df)\n\n# Create baseline scenario\nbaseline = create_scenario(\"baseline\", data)\n\n# Create treatment scenarios\ntreatment_on = create_scenario(\"treatment_on\", data; \n    treatment = true,\n    dose = 100.0  # Add new variable\n)\n\ntreatment_off = create_scenario(\"treatment_off\", data;\n    treatment = false,\n    dose = 0.0\n)\n\n# Policy scenarios\npolicy_scenario = create_scenario(\"policy\", data;\n    x = mean(df.x),           # Set to population mean\n    group = \"A\",              # Override categorical\n    regulatory_flag = true    # Add policy variable\n)","category":"page"},{"location":"guide/advanced_features/#Scenario-Evaluation","page":"Advanced Features","title":"Scenario Evaluation","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Use scenarios with compiled formulas:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"model = lm(@formula(y ~ x * treatment + group), df)\ncompiled = compile_formula(model, data)  # Compile with original data\nrow_vec = Vector{Float64}(undef, length(compiled))\n\n# Evaluate different scenarios for the same individual\ncompiled(row_vec, baseline.data, 1)      # Original data\ncompiled(row_vec, treatment_on.data, 1)  # With treatment\ncompiled(row_vec, treatment_off.data, 1) # Without treatment\ncompiled(row_vec, policy_scenario.data, 1) # Policy scenario","category":"page"},{"location":"guide/advanced_features/#Scenario-Grids","page":"Advanced Features","title":"Scenario Grids","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Generate all combinations of scenario parameters:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"# Create comprehensive policy analysis\npolicy_grid = create_scenario_grid(\"policy_analysis\", data, Dict(\n    :treatment => [false, true],\n    :dose => [50.0, 100.0, 150.0],\n    :region => [\"North\", \"South\", \"East\", \"West\"]\n))\n\n# This creates 2×3×4 = 24 scenarios\nlength(policy_grid)  # 24\n\n# Evaluate all scenarios for a specific individual\nresults = Matrix{Float64}(undef, length(policy_grid), length(compiled))\nfor (i, scenario) in enumerate(policy_grid)\n    compiled(view(results, i, :), scenario.data, 1)\nend\n\n# Each row represents one scenario combination","category":"page"},{"location":"guide/advanced_features/#Dynamic-Scenario-Modification","page":"Advanced Features","title":"Dynamic Scenario Modification","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Modify scenarios after creation:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"scenario = create_scenario(\"dynamic\", data; x = 1.0)\n\n# Add new overrides\nset_override!(scenario, :y, 100.0)\nset_override!(scenario, :new_var, 42.0)\n\n# Bulk updates\nupdate_scenario!(scenario; \n    x = 2.0, \n    z = 0.5,\n    treatment = true\n)\n\n# Remove overrides\nremove_override!(scenario, :y)\n\n# Check current overrides\nget_overrides(scenario)  # Dict of current overrides","category":"page"},{"location":"guide/advanced_features/#Advanced-Compilation-Features","page":"Advanced Features","title":"Advanced Compilation Features","text":"","category":"section"},{"location":"guide/advanced_features/#Introspection-and-Performance","page":"Advanced Features","title":"Introspection and Performance","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Profile compilation performance:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using BenchmarkTools\n\n# Benchmark compilation time\n@benchmark compile_formula($model, $data)","category":"page"},{"location":"guide/advanced_features/#Derivatives-and-Contrasts","page":"Advanced Features","title":"Derivatives and Contrasts","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Near-Zero-Allocation Automatic Differentiation: Compute per-row derivatives of the model row with respect to selected variables using optimized ForwardDiff-based system.","category":"page"},{"location":"guide/advanced_features/#Performance-Characteristics","page":"Advanced Features","title":"Performance Characteristics","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Core evaluation: Exactly 0 allocations (modelrow!, compiled functions)\nForwardDiff derivatives: ≤112 bytes per call (ForwardDiff internals, unavoidable)\nMarginal effects: ≤256 bytes per call (optimized with preallocated buffers)  \nAllocation efficiency: >99.75% compared to naive AD approaches\nValidation: Cross-validated against finite differences for robustness","category":"page"},{"location":"guide/advanced_features/#ForwardDiff-Based-Derivatives","page":"Advanced Features","title":"ForwardDiff-Based Derivatives","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using ForwardDiff, GLM\n\ncompiled = compile_formula(model, data)\nvars = [:x, :z]  # choose continuous vars\nde = build_derivative_evaluator(compiled, data; vars=vars)\n\n# Pre-allocate Jacobian matrix (reused across calls)\nJ = Matrix{Float64}(undef, length(compiled), length(vars))\nderivative_modelrow!(J, de, 1)  # ~112 bytes, near-optimal\n\n# Marginal effects η = Xβ (uses preallocated buffers)\nβ = coef(model)\ng_eta = marginal_effects_eta(de, β, 1)  # ~112 bytes\n\n# GLM mean μ = g⁻¹(η) with link functions\ng_mu = marginal_effects_mu(de, β, 1; link=LogitLink())  # ~112-256 bytes","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Finite-difference fallback (simple and robust):","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"J_fd = derivative_modelrow_fd(compiled, data, 1; vars=vars)","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Discrete contrasts for categorical variables:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Δ = contrast_modelrow(compiled, data, 1; var=:group3, from=\"A\", to=\"B\")","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Tips:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Variable selection: continuous_variables(compiled, data) returns a convenient list of continuous symbols present in the compiled ops. Pass a subset to build_derivative_evaluator via vars=....\nChunking: build_derivative_evaluator(...; chunk=:auto) uses ForwardDiff.Chunk{N} where N = length(vars). You can pass an explicit ForwardDiff.Chunk{K}() if you want to tune performance for larger N.\nLinks: marginal_effects_mu supports common GLM links including IdentityLink(), LogLink(), LogitLink(), ProbitLink(), CloglogLink(), CauchitLink(), InverseLink(), and SqrtLink() (and InverseSquareLink() when available). Extendable as needed.","category":"page"},{"location":"guide/advanced_features/#Mixed-Models-(Fixed-Effects)","page":"Advanced Features","title":"Mixed Models (Fixed Effects)","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Derivatives target the fixed-effects design (random effects are intentionally excluded):","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using MixedModels\n\ndf = DataFrame(y = randn(500), x = randn(500), z = abs.(randn(500)) .+ 0.1,\n               group = categorical(rand(1:20, 500)))\nmm = fit(MixedModel, @formula(y ~ 1 + x + z + (1|group)), df; progress=false)\n\ndata = Tables.columntable(df)\ncompiled = compile_formula(mm, data)  # fixed-effects only\nvars = [:x, :z]\nde = build_derivative_evaluator(compiled, data; vars=vars)\n\nJ = Matrix{Float64}(undef, length(compiled), length(vars))\nderivative_modelrow!(J, de, 1)","category":"page"},{"location":"guide/advanced_features/#Architecture-and-Optimization","page":"Advanced Features","title":"Architecture and Optimization","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"The derivative system achieves near-zero allocations through:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Preallocated buffers: Jacobian matrices, gradient vectors, and temporary arrays stored in DerivativeEvaluator\nTyped closures: Compile-time specialization eliminates runtime dispatch\nPrebuilt data structures: Override vectors and merged data reused across calls\nOptimized memory layout: All allocations front-loaded during evaluator construction","category":"page"},{"location":"guide/advanced_features/#Performance-Benchmarking","page":"Advanced Features","title":"Performance Benchmarking","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using BenchmarkTools\n\n# Build evaluator once (one-time cost)\nde = build_derivative_evaluator(compiled, data; vars=[:x, :z])\nJ = Matrix{Float64}(undef, length(compiled), length(de.vars))\n\n# Benchmark derivatives (~112 bytes, near-theoretical minimum)\n@benchmark derivative_modelrow!($J, $de, 25)\n\n# Benchmark marginal effects (~112-256 bytes with preallocated buffers)  \nβ = coef(model)\ng = Vector{Float64}(undef, length(de.vars))\n@benchmark marginal_effects_eta!($g, $de, $β, 25)","category":"page"},{"location":"guide/advanced_features/#Complex-Formula-Support","page":"Advanced Features","title":"Complex Formula Support","text":"","category":"section"},{"location":"guide/advanced_features/#Nested-Functions","page":"Advanced Features","title":"Nested Functions","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"FormulaCompiler.jl handles complex nested functions:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"@formula(y ~ log(sqrt(abs(x))) + exp(sin(z)) * group)","category":"page"},{"location":"guide/advanced_features/#Boolean-Logic","page":"Advanced Features","title":"Boolean Logic","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Sophisticated boolean expressions:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"@formula(y ~ (x > 0) * (z < mean(z)) + (group == \"A\") * log(w))","category":"page"},{"location":"guide/advanced_features/#Custom-Functions","page":"Advanced Features","title":"Custom Functions","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Define custom functions for use in formulas:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"# Define custom function\ncustom_transform(x) = x > 0 ? log(1 + x) : -log(1 - x)\n\n# Use in formula (requires function to be defined in scope)\n@formula(y ~ custom_transform(x) + group)","category":"page"},{"location":"guide/advanced_features/#High-Performance-Patterns","page":"Advanced Features","title":"High-Performance Patterns","text":"","category":"section"},{"location":"guide/advanced_features/#Avoiding-Allocation-in-Loops","page":"Advanced Features","title":"Avoiding Allocation in Loops","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"# Pre-compile and pre-allocate\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\nresults = Matrix{Float64}(undef, n_simulations, length(compiled))\n\n# Monte Carlo simulation with zero allocations\nfor sim in 1:n_simulations\n    for row in 1:nrow(df)\n        compiled(row_vec, data, row)\n        \n        # Apply some transformation to row_vec\n        results[sim, :] .= some_transformation(row_vec)\n        \n        # Continue processing...\n    end\nend","category":"page"},{"location":"guide/advanced_features/#Batch-Processing-Large-Datasets","page":"Advanced Features","title":"Batch Processing Large Datasets","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"function process_large_dataset(model, data, batch_size=1000)\n    compiled = compile_formula(model, data)\n    n_rows = Tables.rowcount(data)\n    n_cols = length(compiled)\n    \n    results = Vector{Matrix{Float64}}()\n    \n    for start_idx in 1:batch_size:n_rows\n        end_idx = min(start_idx + batch_size - 1, n_rows)\n        batch_size_actual = end_idx - start_idx + 1\n        \n        batch_result = Matrix{Float64}(undef, batch_size_actual, n_cols)\n        modelrow!(batch_result, compiled, data, start_idx:end_idx)\n        \n        push!(results, batch_result)\n    end\n    \n    return results\nend","category":"page"},{"location":"guide/advanced_features/#Parallel-Processing","page":"Advanced Features","title":"Parallel Processing","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Combine with Julia's parallel processing capabilities:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using Distributed\n\n@everywhere using FormulaCompiler, DataFrames, Tables\n\nfunction parallel_evaluation(model, data, row_indices)\n    compiled = compile_formula(model, data)\n    \n    results = @distributed (vcat) for row_idx in row_indices\n        row_vec = Vector{Float64}(undef, length(compiled))\n        compiled(row_vec, data, row_idx)\n        row_vec'  # Return as row matrix\n    end\n    \n    return results\nend","category":"page"},{"location":"guide/advanced_features/#Integration-with-Optimization","page":"Advanced Features","title":"Integration with Optimization","text":"","category":"section"},{"location":"guide/advanced_features/#Gradient-Based-Optimization","page":"Advanced Features","title":"Gradient-Based Optimization","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"FormulaCompiler.jl works well with automatic differentiation:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using ForwardDiff\n\nfunction objective_function(params, compiled_formula, data, target)\n    # Update data with new parameters\n    modified_data = (; data..., x = params[1], z = params[2])\n    \n    row_vec = Vector{Float64}(undef, length(compiled_formula))\n    compiled_formula(row_vec, modified_data, 1)\n    \n    # Compute loss\n    return sum((row_vec .- target).^2)\nend\n\n# Use with ForwardDiff for gradients\ncompiled = compile_formula(model, data)\ntarget = [1.0, 2.0, 3.0, 4.0]  # Target model matrix row\n\ngradient = ForwardDiff.gradient(\n    params -> objective_function(params, compiled, data, target),\n    [0.0, 1.0]  # Initial parameters\n)","category":"page"},{"location":"guide/advanced_features/#Bayesian-Analysis-Integration","page":"Advanced Features","title":"Bayesian Analysis Integration","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Efficient model evaluation in MCMC samplers:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using MCMCChains\n\nfunction log_likelihood(params, compiled_formula, data, y_observed)\n    # Extract parameters\n    β = params[1:length(compiled_formula)]\n    σ = exp(params[end])  # Log-scale for positivity\n    \n    n_obs = length(y_observed)\n    row_vec = Vector{Float64}(undef, length(compiled_formula))\n    \n    ll = 0.0\n    for i in 1:n_obs\n        compiled_formula(row_vec, data, i)\n        μ = dot(β, row_vec)\n        ll += logpdf(Normal(μ, σ), y_observed[i])\n    end\n    \n    return ll\nend\n\n# Use in MCMC sampler (pseudocode)\n# sampler = MCMCSampler(log_likelihood, compiled, data, y)","category":"page"},{"location":"guide/advanced_features/#Memory-and-Performance-Monitoring","page":"Advanced Features","title":"Memory and Performance Monitoring","text":"","category":"section"},{"location":"guide/advanced_features/#Allocation-Tracking","page":"Advanced Features","title":"Allocation Tracking","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"Monitor allocation performance:","category":"page"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using BenchmarkTools\n\nfunction check_allocations(compiled, data, n_tests=1000)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    # Warm up\n    compiled(row_vec, data, 1)\n    \n    # Benchmark\n    result = @benchmark begin\n        for i in 1:$n_tests\n            $compiled($row_vec, $data, i % nrow($data) + 1)\n        end\n    end\n    \n    return result\nend\n\n# Should show 0 allocations\nbenchmark_result = check_allocations(compiled, data)","category":"page"},{"location":"guide/advanced_features/#Memory-Usage-Analysis","page":"Advanced Features","title":"Memory Usage Analysis","text":"","category":"section"},{"location":"guide/advanced_features/","page":"Advanced Features","title":"Advanced Features","text":"using Profile\n\nfunction profile_memory_usage(model, data, n_evaluations=10000)\n    compiled = compile_formula(model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    # Profile memory\n    Profile.clear_malloc_data()\n    \n    for i in 1:n_evaluations\n        compiled(row_vec, data, i % nrow(data) + 1)\n    end\n    \n    # Analyze results\n    # (Use ProfileView.jl or similar for visualization)\nend","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will walk you through the basics of using FormulaCompiler.jl to achieve zero-allocation model matrix evaluation.","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"FormulaCompiler.jl is currently available from GitHub:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(url=\"https://github.com/emfeltham/FormulaCompiler.jl\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once installed, you can load the package:","category":"page"},{"location":"getting_started/#Workflow-Overview","page":"Getting Started","title":"Workflow Overview","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here's how FormulaCompiler.jl works from start to finish:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: Diagram)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using FormulaCompiler","category":"page"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The typical workflow with FormulaCompiler.jl involves three steps:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Fit your model using standard Julia statistical packages\nCompile the formula for optimized evaluation\nEvaluate rows with zero allocations","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's walk through a complete example:","category":"page"},{"location":"getting_started/#Step-1:-Fit-Your-Model","page":"Getting Started","title":"Step 1: Fit Your Model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using FormulaCompiler, GLM, DataFrames, Tables, CategoricalArrays\n\n# Create some sample data\ndf = DataFrame(\n    y = randn(1000),\n    x = randn(1000),\n    z = abs.(randn(1000)) .+ 0.1,\n    group = categorical(rand([\"A\", \"B\", \"C\"], 1000)),\n    treatment = rand(Bool, 1000)\n)\n\n# Fit a model using GLM.jl (or any compatible package)\nmodel = lm(@formula(y ~ x * group + log(z) + treatment), df)","category":"page"},{"location":"getting_started/#Step-2:-Compile-the-Formula","page":"Getting Started","title":"Step 2: Compile the Formula","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Convert your data to column-table format for best performance:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"data = Tables.columntable(df)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Compile the formula:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"compiled = compile_formula(model, data)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The compiled formula contains all the information needed for zero-allocation evaluation.","category":"page"},{"location":"getting_started/#Step-3:-Evaluate-Rows","page":"Getting Started","title":"Step 3: Evaluate Rows","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Pre-allocate an output vector:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"row_vec = Vector{Float64}(undef, length(compiled))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now evaluate any row with zero allocations:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"compiled(row_vec, data, 1)    # Evaluate row 1\ncompiled(row_vec, data, 100)  # Evaluate row 100\ncompiled(row_vec, data, 500)  # Evaluate row 500","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Each call takes ~50ns and allocates 0 bytes!","category":"page"},{"location":"getting_started/#Alternative-Interfaces","page":"Getting Started","title":"Alternative Interfaces","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"FormulaCompiler.jl provides several interfaces for different use cases:","category":"page"},{"location":"getting_started/#Convenient-Interface-(Allocating)","page":"Getting Started","title":"Convenient Interface (Allocating)","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For quick prototyping or when allocation performance isn't critical:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Single row evaluation\nrow_values = modelrow(model, data, 1)\n\n# Multiple rows\nrow_indices = [1, 10, 50, 100]\nmatrix = modelrow(model, data, row_indices)","category":"page"},{"location":"getting_started/#Object-Based-Interface","page":"Getting Started","title":"Object-Based Interface","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Create a reusable evaluator object:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"evaluator = ModelRowEvaluator(model, df)\n\n# Zero-allocation evaluation\nresult = evaluator(1)           # Returns new vector\nevaluator(row_vec, 1)          # In-place evaluation","category":"page"},{"location":"getting_started/#Batch-Evaluation","page":"Getting Started","title":"Batch Evaluation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Evaluate multiple rows at once:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Pre-allocate matrix\nmatrix = Matrix{Float64}(undef, 10, length(compiled))\n\n# Evaluate rows 1-10 in batch\nmodelrow!(matrix, compiled, data, 1:10)","category":"page"},{"location":"getting_started/#How-Compilation-Works","page":"Getting Started","title":"How Compilation Works","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"FormulaCompiler.jl uses a unified compilation pipeline based on position mapping:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Decompose the formula into primitive operations (load, constant, unary, binary, contrast, copy)\nAllocate scratch and output positions for all intermediate and final values\nEmbed those positions as compile-time type parameters\nReturn a UnifiedCompiled object that evaluates rows with zero allocations","category":"page"},{"location":"getting_started/#Performance-Verification","page":"Getting Started","title":"Performance Verification","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can verify zero-allocation performance using BenchmarkTools.jl:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using BenchmarkTools\n\n# Benchmark the zero-allocation interface\n@benchmark $compiled($row_vec, $data, 1)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You should see output like:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"BenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  45.123 ns … 67.891 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     48.456 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   49.234 ns ±  2.345 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Compare this to the traditional approach:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@benchmark modelmatrix($model)[1, :]","category":"page"},{"location":"getting_started/#What's-Next?","page":"Getting Started","title":"What's Next?","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now that you understand the basics, you can explore:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Advanced Features - Scenario analysis and memory optimization\nPerformance Tips - Getting the most out of FormulaCompiler.jl\nExamples - Real-world use cases and patterns\nAPI Reference - Complete function documentation","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Real-world examples demonstrating FormulaCompiler.jl in action.","category":"page"},{"location":"examples/#Monte-Carlo-Simulation","page":"Examples","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"High-performance Monte Carlo simulation using zero-allocation evaluation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using FormulaCompiler, GLM, DataFrames, Tables, Random\nusing BenchmarkTools, Statistics\n\nfunction monte_carlo_simulation(n_sims=1_000_000, n_obs=1000)\n    # Generate base dataset\n    Random.seed!(123)\n    df = DataFrame(\n        y = randn(n_obs),\n        x = randn(n_obs),\n        z = abs.(randn(n_obs)) .+ 0.1,\n        treatment = rand(Bool, n_obs),\n        group = categorical(rand([\"A\", \"B\", \"C\"], n_obs))\n    )\n    \n    # Fit model\n    model = lm(@formula(y ~ x * treatment + log(z) + group), df)\n    data = Tables.columntable(df)\n    \n    # Compile for zero-allocation evaluation\n    compiled = compile_formula(model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    # Pre-allocate results\n    results = Vector{Float64}(undef, n_sims)\n    \n    println(\"Running $n_sims Monte Carlo simulations...\")\n    @time begin\n        for sim in 1:n_sims\n            # Random row selection\n            row_idx = rand(1:n_obs)\n            \n            # Zero-allocation evaluation\n            compiled(row_vec, data, row_idx)\n            \n            # Calculate linear predictor\n            results[sim] = dot(coef(model), row_vec)\n        end\n    end\n    \n    return results\nend\n\n# Run simulation\nmc_results = monte_carlo_simulation(1_000_000, 1000)\n\nprintln(\"Monte Carlo Results:\")\nprintln(\"Mean: $(round(mean(mc_results), digits=4))\")\nprintln(\"Std:  $(round(std(mc_results), digits=4))\")\nprintln(\"Min:  $(round(minimum(mc_results), digits=4))\")  \nprintln(\"Max:  $(round(maximum(mc_results), digits=4))\")","category":"page"},{"location":"examples/#Bootstrap-Confidence-Intervals","page":"Examples","title":"Bootstrap Confidence Intervals","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Efficient bootstrap resampling for coefficient confidence intervals:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Random\n\nfunction bootstrap_confidence_intervals(model, data, n_bootstrap=1000, confidence=0.95)\n    compiled = compile_formula(model, data)\n    n_obs = Tables.rowcount(data)\n    n_coefs = length(compiled)\n    \n    # Get response variable\n    y_name = Symbol(model.mf.f.lhs)\n    y = data[y_name]\n    \n    # Pre-allocate\n    bootstrap_coefs = Matrix{Float64}(undef, n_bootstrap, n_coefs)\n    row_vec = Vector{Float64}(undef, n_coefs)\n    X_bootstrap = Matrix{Float64}(undef, n_obs, n_coefs)\n    y_bootstrap = Vector{Float64}(undef, n_obs)\n    \n    println(\"Computing $n_bootstrap bootstrap samples...\")\n    @time begin\n        for b in 1:n_bootstrap\n            # Generate bootstrap sample indices\n            sample_indices = rand(1:n_obs, n_obs)\n            \n            # Build design matrix for bootstrap sample (zero allocations)\n            for (i, idx) in enumerate(sample_indices)\n                compiled(row_vec, data, idx)\n                X_bootstrap[i, :] .= row_vec\n                y_bootstrap[i] = y[idx]\n            end\n            \n            # Compute bootstrap coefficients\n            bootstrap_coefs[b, :] = X_bootstrap \\ y_bootstrap\n        end\n    end\n    \n    # Calculate confidence intervals\n    α = 1 - confidence\n    lower_percentile = 100 * (α/2)\n    upper_percentile = 100 * (1 - α/2)\n    \n    coef_names = coefnames(model)\n    original_coefs = coef(model)\n    \n    println(\"\\n$(Int(confidence*100))% Bootstrap Confidence Intervals:\")\n    println(\"─\"^60)\n    \n    for (i, name) in enumerate(coef_names)\n        boot_coefs_i = bootstrap_coefs[:, i]\n        lower = percentile(boot_coefs_i, lower_percentile)\n        upper = percentile(boot_coefs_i, upper_percentile)\n        \n        println(\"$name:\")\n        println(\"  Original: $(round(original_coefs[i], digits=4))\")\n        println(\"  Bootstrap: [$(round(lower, digits=4)), $(round(upper, digits=4))]\")\n        println(\"  Bootstrap SE: $(round(std(boot_coefs_i), digits=4))\")\n    end\n    \n    return bootstrap_coefs\nend\n\n# Example usage\ndf = DataFrame(\n    y = randn(500),\n    x = randn(500),\n    treatment = rand(Bool, 500),\n    age = rand(20:80, 500)\n)\n\nmodel = lm(@formula(y ~ x * treatment + age), df)\ndata = Tables.columntable(df)\n\nboot_coefs = bootstrap_confidence_intervals(model, data, 1000, 0.95)","category":"page"},{"location":"examples/#Policy-Impact-Analysis","page":"Examples","title":"Policy Impact Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Comprehensive policy scenario analysis using the scenario system:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function policy_impact_analysis()\n    # Simulate policy-relevant dataset\n    Random.seed!(456)\n    n_individuals = 10000\n    \n    df = DataFrame(\n        # Outcome: earnings (thousands)\n        earnings = max.(0, randn(n_individuals) * 15 .+ 45),\n        \n        # Demographics\n        age = rand(22:65, n_individuals),\n        education_years = rand(10:18, n_individuals),\n        experience = rand(0:30, n_individuals),\n        \n        # Geographic\n        region = categorical(rand([\"North\", \"South\", \"East\", \"West\"], n_individuals)),\n        urban = rand(Bool, n_individuals),\n        \n        # Current programs\n        job_training = rand(Bool, n_individuals),\n        healthcare_access = rand(Bool, n_individuals)\n    )\n    \n    # Fit earnings model\n    model = lm(@formula(earnings ~ age + education_years + experience + \n                                 region + urban + job_training * healthcare_access), df)\n    \n    data = Tables.columntable(df)\n    compiled = compile_formula(model, data)\n    \n    # Define policy scenarios\n    scenarios = Dict(\n        \"status_quo\" => create_scenario(\"status_quo\", data),\n        \n        \"universal_training\" => create_scenario(\"universal_training\", data;\n            job_training = true\n        ),\n        \n        \"universal_healthcare\" => create_scenario(\"universal_healthcare\", data;\n            healthcare_access = true  \n        ),\n        \n        \"combined_programs\" => create_scenario(\"combined\", data;\n            job_training = true,\n            healthcare_access = true\n        ),\n        \n        \"education_boost\" => create_scenario(\"education_boost\", data;\n            education_years = mean(df.education_years) + 2  # +2 years education\n        ),\n        \n        \"comprehensive_policy\" => create_scenario(\"comprehensive\", data;\n            job_training = true,\n            healthcare_access = true, \n            education_years = mean(df.education_years) + 1,\n            urban = true  # Urbanization investment\n        )\n    )\n    \n    # Evaluate policy impacts\n    results = Dict{String, NamedTuple}()\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    println(\"Policy Impact Analysis Results:\")\n    println(\"=\"^50)\n    \n    for (policy_name, scenario) in scenarios\n        predictions = Vector{Float64}(undef, n_individuals)\n        \n        # Calculate predictions for all individuals under this policy\n        for i in 1:n_individuals\n            compiled(row_vec, scenario.data, i)\n            predictions[i] = dot(coef(model), row_vec)\n        end\n        \n        # Calculate impacts vs status quo\n        if policy_name != \"status_quo\"\n            status_quo_preds = Vector{Float64}(undef, n_individuals)\n            for i in 1:n_individuals\n                compiled(row_vec, scenarios[\"status_quo\"].data, i)\n                status_quo_preds[i] = dot(coef(model), row_vec)\n            end\n            \n            individual_impacts = predictions .- status_quo_preds\n            \n            results[policy_name] = (\n                mean_earnings = mean(predictions),\n                mean_impact = mean(individual_impacts),\n                median_impact = median(individual_impacts),\n                impact_std = std(individual_impacts),\n                percent_helped = 100 * mean(individual_impacts .> 0),\n                total_cost = sum(max.(0, individual_impacts)) * 1000  # Total $ impact\n            )\n        else\n            results[policy_name] = (\n                mean_earnings = mean(predictions),\n                mean_impact = 0.0,\n                median_impact = 0.0,\n                impact_std = 0.0,\n                percent_helped = 0.0,\n                total_cost = 0.0\n            )\n        end\n    end\n    \n    # Display results\n    baseline_earnings = results[\"status_quo\"].mean_earnings\n    \n    for (policy, stats) in results\n        if policy == \"status_quo\"\n            println(\"$policy (baseline):\")\n            println(\"  Mean earnings: \\$$(round(Int, stats.mean_earnings))k\")\n        else\n            println(\"\\n$policy:\")\n            println(\"  Mean earnings: \\$$(round(Int, stats.mean_earnings))k\")\n            println(\"  Mean impact: \\$$(round(Int, stats.mean_impact))k per person\")\n            println(\"  Median impact: \\$$(round(Int, stats.median_impact))k per person\") \n            println(\"  % individuals helped: $(round(stats.percent_helped, digits=1))%\")\n            println(\"  Total economic impact: \\$$(round(Int, stats.total_cost/1000))M\")\n            \n            # Cost-effectiveness (simplified)\n            if policy == \"universal_training\"\n                cost_per_person = 5000  # $5k per person for training\n            elseif policy == \"universal_healthcare\"\n                cost_per_person = 8000  # $8k per person for healthcare\n            elseif policy == \"combined_programs\"  \n                cost_per_person = 12000  # $12k for both\n            elseif policy == \"education_boost\"\n                cost_per_person = 15000  # $15k for education\n            else\n                cost_per_person = 20000  # $20k comprehensive\n            end\n            \n            total_program_cost = cost_per_person * n_individuals / 1000  # In thousands\n            net_benefit = stats.total_cost - total_program_cost\n            roi = (net_benefit / total_program_cost) * 100\n            \n            println(\"  Program cost: \\$$(round(Int, total_program_cost/1000))M\")\n            println(\"  Net benefit: \\$$(round(Int, net_benefit/1000))M\")\n            println(\"  ROI: $(round(roi, digits=1))%\")\n        end\n    end\n    \n    return results, scenarios\nend\n\n# Run the analysis\npolicy_results, policy_scenarios = policy_impact_analysis()","category":"page"},{"location":"examples/#Marginal-Effects-Calculation","page":"Examples","title":"Marginal Effects Calculation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Efficient numerical derivatives for marginal effects:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function marginal_effects_analysis(model, data, variables=nothing; delta=0.01)\n    compiled = compile_formula(model, data)\n    n_obs = Tables.rowcount(data)\n    n_coefs = length(compiled)\n    \n    # Default to all continuous variables\n    if variables === nothing\n        variables = [:age, :experience, :education_years]  # Adjust as needed\n    end\n    \n    results = Dict{Symbol, Matrix{Float64}}()\n    row_vec_orig = Vector{Float64}(undef, n_coefs)\n    row_vec_pert = Vector{Float64}(undef, n_coefs)\n    \n    for var in variables\n        println(\"Computing marginal effects for $var...\")\n        \n        # Get original values\n        original_values = data[var]\n        perturbed_values = original_values .+ delta\n        perturbed_data = (; data..., var => perturbed_values)\n        \n        marginal_effects = Matrix{Float64}(undef, n_obs, n_coefs)\n        \n        @time begin\n            for i in 1:n_obs\n                # Original prediction\n                compiled(row_vec_orig, data, i)\n                \n                # Perturbed prediction  \n                compiled(row_vec_pert, perturbed_data, i)\n                \n                # Marginal effects for each coefficient\n                marginal_effects[i, :] .= (row_vec_pert .- row_vec_orig) ./ delta\n            end\n        end\n        \n        results[var] = marginal_effects\n    end\n    \n    # Summarize results\n    coef_names = coefnames(model)\n    println(\"\\nMarginal Effects Summary:\")\n    println(\"=\"^40)\n    \n    for var in variables\n        println(\"\\nVariable: $var\")\n        me_matrix = results[var]\n        \n        for (j, coef_name) in enumerate(coef_names)\n            me_col = me_matrix[:, j]\n            println(\"  $coef_name:\")\n            println(\"    Mean ME: $(round(mean(me_col), digits=6))\")\n            println(\"    Std ME:  $(round(std(me_col), digits=6))\")\n            println(\"    Range:   [$(round(minimum(me_col), digits=6)), $(round(maximum(me_col), digits=6))]\")\n        end\n    end\n    \n    return results\nend\n\n# Example: marginal effects for policy model\nmarginal_results = marginal_effects_analysis(model, data, [:age, :education_years, :experience])","category":"page"},{"location":"examples/#High-Frequency-Trading-Model","page":"Examples","title":"High-Frequency Trading Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Real-time prediction serving with microsecond latency requirements:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Dates\n\nfunction high_frequency_trading_example()\n    # Simulate high-frequency financial data\n    Random.seed!(789)\n    n_ticks = 100_000\n    \n    # Generate realistic financial time series\n    returns = cumsum(randn(n_ticks) * 0.001)  # Random walk returns\n    \n    df = DataFrame(\n        # Price features\n        return_1min = returns,\n        return_5min = lag(returns, 5),\n        return_15min = lag(returns, 15),\n        \n        # Volume features  \n        volume = abs.(randn(n_ticks)) .+ 1,\n        volume_ratio = rand(0.5:0.01:2.0, n_ticks),\n        \n        # Market microstructure\n        spread = abs.(randn(n_ticks)) * 0.01 .+ 0.001,\n        market_impact = rand(0.001:0.0001:0.01, n_ticks),\n        \n        # Time features\n        hour = repeat(9:16, inner=div(n_ticks, 8))[1:n_ticks],\n        minute = repeat(0:59, inner=div(n_ticks, 60))[1:n_ticks],\n        \n        # Target: next minute return\n        next_return = lead(returns, 1)\n    )\n    \n    # Remove missing values from lags/leads\n    df = df[16:(end-1), :]\n    \n    # Fit high-frequency prediction model\n    model = lm(@formula(next_return ~ return_1min + return_5min + return_15min + \n                                    log(volume) + volume_ratio + spread + \n                                    market_impact + hour), df)\n    \n    data = Tables.columntable(df)\n    compiled = compile_formula(model, data)\n    \n    # Simulate real-time prediction serving\n    println(\"High-Frequency Trading Model Performance:\")\n    println(\"Model coefficients: \", length(compiled))\n    \n    # Pre-allocate for zero-allocation serving\n    row_vec = Vector{Float64}(undef, length(compiled))\n    n_predictions = 10_000\n    \n    # Benchmark prediction latency\n    prediction_times = Vector{Float64}(undef, n_predictions)\n    predictions = Vector{Float64}(undef, n_predictions)\n    \n    println(\"Serving $n_predictions real-time predictions...\")\n    \n    for i in 1:n_predictions\n        tick_idx = rand(1:nrow(df))\n        \n        start_time = time_ns()\n        compiled(row_vec, data, tick_idx)\n        prediction = dot(coef(model), row_vec)\n        end_time = time_ns()\n        \n        prediction_times[i] = (end_time - start_time) / 1000  # Convert to microseconds\n        predictions[i] = prediction\n    end\n    \n    # Latency analysis\n    println(\"\\nLatency Analysis:\")\n    println(\"Mean latency: $(round(mean(prediction_times), digits=2)) μs\")\n    println(\"Median latency: $(round(median(prediction_times), digits=2)) μs\") \n    println(\"95th percentile: $(round(quantile(prediction_times, 0.95), digits=2)) μs\")\n    println(\"99th percentile: $(round(quantile(prediction_times, 0.99), digits=2)) μs\")\n    println(\"Max latency: $(round(maximum(prediction_times), digits=2)) μs\")\n    \n    # Trading performance metrics\n    actual_returns = [data.next_return[rand(1:nrow(df))] for _ in 1:n_predictions]\n    \n    # Simple trading strategy: long if predicted return > 0\n    positions = sign.(predictions)\n    strategy_returns = positions .* actual_returns\n    \n    println(\"\\nTrading Strategy Performance:\")\n    println(\"Total predictions: $n_predictions\")\n    println(\"Accuracy (direction): $(round(100 * mean(sign.(predictions) .== sign.(actual_returns)), digits=1))%\")\n    println(\"Mean strategy return: $(round(mean(strategy_returns) * 10000, digits=2)) bps\")\n    println(\"Strategy Sharpe ratio: $(round(mean(strategy_returns) / std(strategy_returns), digits=3))\")\n    println(\"Max drawdown: $(round(minimum(cumsum(strategy_returns)) * 100, digits=2))%\")\n    \n    return (latencies = prediction_times, predictions = predictions, returns = strategy_returns)\nend\n\n# Run high-frequency trading example\nhft_results = high_frequency_trading_example()","category":"page"},{"location":"examples/#Medical-Research:-Clinical-Trial-Simulation","page":"Examples","title":"Medical Research: Clinical Trial Simulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simulating clinical trial outcomes with patient heterogeneity:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function clinical_trial_simulation()\n    # Simulate diverse patient population\n    Random.seed!(101112)\n    n_patients = 5000\n    \n    df = DataFrame(\n        # Patient demographics\n        age = rand(18:85, n_patients),\n        sex = categorical(rand([\"Male\", \"Female\"], n_patients)),\n        bmi = max.(15, randn(n_patients) * 5 .+ 25),\n        \n        # Baseline health\n        baseline_severity = rand(1:10, n_patients),\n        comorbidities = rand(0:5, n_patients),\n        \n        # Treatment assignment (randomized)\n        treatment = categorical(rand([\"Placebo\", \"Low_Dose\", \"High_Dose\"], n_patients)),\n        \n        # Compliance (realistic patterns)\n        compliance_rate = min.(1.0, max.(0.0, randn(n_patients) * 0.2 .+ 0.8)),\n        \n        # Outcome: improvement score (0-100)\n        improvement = max.(0, min.(100, \n            randn(n_patients) * 15 .+ \n            (df.treatment .== \"High_Dose\") * 20 .+\n            (df.treatment .== \"Low_Dose\") * 10 .-\n            df.baseline_severity * 2 .+\n            df.compliance_rate * 15\n        ))\n    )\n    \n    # Clinical model\n    model = lm(@formula(improvement ~ age + sex + bmi + baseline_severity + \n                                    comorbidities + treatment * compliance_rate), df)\n    \n    data = Tables.columntable(df)\n    compiled = compile_formula(model, data)\n    \n    # Define clinical scenarios\n    scenarios = Dict(\n        \"real_world\" => create_scenario(\"real_world\", data),\n        \n        \"perfect_compliance\" => create_scenario(\"perfect_compliance\", data;\n            compliance_rate = 1.0\n        ),\n        \n        \"elderly_subgroup\" => create_scenario(\"elderly\", data;\n            age = 70,  # All patients age 70\n            compliance_rate = 0.9\n        ),\n        \n        \"high_risk_patients\" => create_scenario(\"high_risk\", data;\n            baseline_severity = 8,\n            comorbidities = 3,\n            bmi = 30\n        ),\n        \n        \"optimal_candidates\" => create_scenario(\"optimal\", data;\n            age = 45,\n            baseline_severity = 5,\n            comorbidities = 1,\n            bmi = 23,\n            compliance_rate = 1.0\n        )\n    )\n    \n    # Analyze treatment effects across scenarios\n    println(\"Clinical Trial Scenario Analysis:\")\n    println(\"=\"^50)\n    \n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    for (scenario_name, scenario) in scenarios\n        println(\"\\nScenario: $scenario_name\")\n        \n        # Calculate outcomes by treatment group\n        treatment_groups = [\"Placebo\", \"Low_Dose\", \"High_Dose\"]\n        group_results = Dict{String, Float64}()\n        \n        for treatment_group in treatment_groups\n            # Create scenario with specific treatment\n            treatment_scenario = create_scenario(\"temp\", scenario.data;\n                treatment = treatment_group\n            )\n            \n            # Predict outcomes for all patients under this treatment\n            outcomes = Vector{Float64}(undef, n_patients)\n            for i in 1:n_patients\n                compiled(row_vec, treatment_scenario.data, i)\n                outcomes[i] = dot(coef(model), row_vec)\n            end\n            \n            group_results[treatment_group] = mean(outcomes)\n        end\n        \n        # Calculate treatment effects\n        placebo_effect = group_results[\"Placebo\"]\n        low_dose_effect = group_results[\"Low_Dose\"] - placebo_effect\n        high_dose_effect = group_results[\"High_Dose\"] - placebo_effect\n        dose_response = high_dose_effect - low_dose_effect\n        \n        println(\"  Placebo response: $(round(placebo_effect, digits=1))\")\n        println(\"  Low dose effect: $(round(low_dose_effect, digits=1)) (vs placebo)\")\n        println(\"  High dose effect: $(round(high_dose_effect, digits=1)) (vs placebo)\")\n        println(\"  Dose response: $(round(dose_response, digits=1))\")\n        \n        # Calculate number needed to treat (simplified)\n        if high_dose_effect > 0\n            nnt = round(Int, 100 / high_dose_effect)  # Assume 100-point scale\n            println(\"  Number needed to treat: $nnt\")\n        end\n    end\n    \n    return scenarios, group_results\nend\n\n# Run clinical trial analysis\nclinical_scenarios, clinical_results = clinical_trial_simulation()","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate FormulaCompiler.jl's versatility across:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"High-performance computing: Monte Carlo simulations with millions of evaluations\nStatistical inference: Bootstrap confidence intervals with zero-allocation resampling  \nPolicy analysis: Complex scenario modeling for decision support\nReal-time systems: Microsecond-latency prediction serving\nMedical research: Clinical trial simulation and subgroup analysis","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Each example leverages FormulaCompiler.jl's core strengths: zero-allocation performance, flexible scenario system, and seamless integration with the Julia statistical ecosystem.","category":"page"},{"location":"integration/mixed_models/#MixedModels.jl-Integration","page":"MixedModels.jl","title":"MixedModels.jl Integration","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"FormulaCompiler.jl integrates with MixedModels.jl by automatically extracting fixed effects from mixed-effects models, enabling zero-allocation evaluation of the fixed-effects portion.","category":"page"},{"location":"integration/mixed_models/#Overview","page":"MixedModels.jl","title":"Overview","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"Mixed models contain both fixed and random effects. FormulaCompiler.jl focuses on the fixed effects portion, which is often needed for:","category":"page"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"Marginal effects calculation\nPrediction with population-level effects\nBootstrap inference on fixed effects\nPolicy analysis scenarios","category":"page"},{"location":"integration/mixed_models/#Basic-Integration","page":"MixedModels.jl","title":"Basic Integration","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"using MixedModels, FormulaCompiler, DataFrames, Tables\n\n# Example dataset\ndf = DataFrame(\n    y = randn(1000),\n    x = randn(1000),\n    treatment = rand(Bool, 1000),\n    group = rand(1:10, 1000),\n    cluster = rand(1:50, 1000)\n)\n\n# Fit mixed model\nmixed_model = fit(MixedModel, @formula(y ~ x + treatment + (1|group) + (1+x|cluster)), df)\n\n# FormulaCompiler automatically extracts fixed effects: y ~ x + treatment\ncompiled = compile_formula(mixed_model, Tables.columntable(df))","category":"page"},{"location":"integration/mixed_models/#Fixed-Effects-Extraction","page":"MixedModels.jl","title":"Fixed Effects Extraction","text":"","category":"section"},{"location":"integration/mixed_models/#Automatic-Extraction","page":"MixedModels.jl","title":"Automatic Extraction","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"# Mixed model with various random effects structures\nmixed_model = fit(MixedModel, @formula(y ~ x * treatment + age + (1|group) + (x|cluster)), df)\n\n# Fixed effects formula: y ~ x * treatment + age\nfixed_formula = fixed_effects_form(mixed_model)\nprintln(\"Fixed effects: \", fixed_formula)\n\n# Compile fixed effects only\ncompiled = compile_formula(mixed_model, data)","category":"page"},{"location":"integration/mixed_models/#Manual-Fixed-Effects","page":"MixedModels.jl","title":"Manual Fixed Effects","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"# If you need more control, extract manually\nfixed_form = mixed_model.formula.rhs.terms[1]  # Gets fixed effects terms\nmanual_model = lm(FormulaTerm(mixed_model.formula.lhs, fixed_form), df)\ncompiled_manual = compile_formula(manual_model, data)","category":"page"},{"location":"integration/mixed_models/#Use-Cases","page":"MixedModels.jl","title":"Use Cases","text":"","category":"section"},{"location":"integration/mixed_models/#Population-Level-Predictions","page":"MixedModels.jl","title":"Population-Level Predictions","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"function population_predictions(mixed_model, data, scenarios)\n    # Compile fixed effects\n    compiled = compile_formula(mixed_model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    results = Dict{String, Vector{Float64}}()\n    \n    for (scenario_name, scenario) in scenarios\n        n_obs = Tables.rowcount(scenario.data)\n        predictions = Vector{Float64}(undef, n_obs)\n        \n        for i in 1:n_obs\n            compiled(row_vec, scenario.data, i)\n            # This gives the fixed effects linear predictor\n            predictions[i] = dot(fixef(mixed_model), row_vec)\n        end\n        \n        results[scenario_name] = predictions\n    end\n    \n    return results\nend\n\n# Example usage\nscenarios = Dict(\n    \"baseline\" => create_scenario(\"baseline\", data),\n    \"treatment\" => create_scenario(\"treatment\", data; treatment = true)\n)\n\npop_predictions = population_predictions(mixed_model, data, scenarios)","category":"page"},{"location":"integration/mixed_models/#Marginal-Effects-for-Fixed-Effects","page":"MixedModels.jl","title":"Marginal Effects for Fixed Effects","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"function marginal_effects_mixed(mixed_model, data, variable)\n    compiled = compile_formula(mixed_model, data)\n    fixed_coefs = fixef(mixed_model)\n    \n    # Create perturbed data\n    delta = 0.01\n    original_values = data[variable]\n    perturbed_values = original_values .+ delta\n    perturbed_data = (; data..., variable => perturbed_values)\n    \n    row_vec_orig = Vector{Float64}(undef, length(compiled))\n    row_vec_pert = Vector{Float64}(undef, length(compiled))\n    \n    n_obs = Tables.rowcount(data)\n    marginal_effects = Vector{Float64}(undef, n_obs)\n    \n    for i in 1:n_obs\n        compiled(row_vec_orig, data, i)\n        compiled(row_vec_pert, perturbed_data, i)\n        \n        pred_orig = dot(fixed_coefs, row_vec_orig)\n        pred_pert = dot(fixed_coefs, row_vec_pert)\n        \n        marginal_effects[i] = (pred_pert - pred_orig) / delta\n    end\n    \n    return marginal_effects\nend","category":"page"},{"location":"integration/mixed_models/#Performance-Benefits","page":"MixedModels.jl","title":"Performance Benefits","text":"","category":"section"},{"location":"integration/mixed_models/#Comparison-with-modelmatrix","page":"MixedModels.jl","title":"Comparison with modelmatrix","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"using BenchmarkTools\n\n# Setup mixed model\nmixed_model = fit(MixedModel, @formula(y ~ x + treatment + (1|group)), df)\ndata = Tables.columntable(df)\n\n# Traditional approach: extract full model matrix\nfunction traditional_mixed_row(model, row_idx)\n    # Get fixed effects design matrix\n    X = modelmatrix(model.optsum.lm)  # Linear model component\n    return X[row_idx, :]\nend\n\n# FormulaCompiler approach\ncompiled = compile_formula(mixed_model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\nfunction fc_mixed_row(compiled, data, row_vec, row_idx)\n    compiled(row_vec, data, row_idx)\n    return row_vec\nend\n\n# Benchmark\nprintln(\"Traditional mixed model row extraction:\")\n@benchmark traditional_mixed_row($mixed_model, 1)\n\nprintln(\"FormulaCompiler mixed model row extraction:\")\n@benchmark fc_mixed_row($compiled, $data, $row_vec, 1)","category":"page"},{"location":"integration/mixed_models/#Advanced-Examples","page":"MixedModels.jl","title":"Advanced Examples","text":"","category":"section"},{"location":"integration/mixed_models/#Bootstrap-Fixed-Effects","page":"MixedModels.jl","title":"Bootstrap Fixed Effects","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"function bootstrap_fixed_effects(mixed_model, data, n_bootstrap=1000)\n    compiled = compile_formula(mixed_model, data)\n    n_obs = Tables.rowcount(data)\n    n_coefs = length(compiled)\n    \n    # Get response variable\n    y_var = Symbol(mixed_model.formula.lhs)\n    y = data[y_var]\n    \n    bootstrap_coefs = Matrix{Float64}(undef, n_bootstrap, n_coefs)\n    row_vec = Vector{Float64}(undef, n_coefs)\n    \n    for boot in 1:n_bootstrap\n        # Bootstrap sample\n        sample_idx = rand(1:n_obs, n_obs)\n        \n        # Build design matrix for bootstrap sample\n        X_boot = Matrix{Float64}(undef, n_obs, n_coefs)\n        y_boot = Vector{Float64}(undef, n_obs)\n        \n        for (i, idx) in enumerate(sample_idx)\n            compiled(row_vec, data, idx)\n            X_boot[i, :] .= row_vec\n            y_boot[i] = y[idx]\n        end\n        \n        # Estimate fixed effects (OLS approximation)\n        bootstrap_coefs[boot, :] = X_boot \\ y_boot\n    end\n    \n    return bootstrap_coefs\nend\n\n# Usage\nboot_coefs = bootstrap_fixed_effects(mixed_model, data, 1000)\n\n# Confidence intervals\nusing Statistics\nconf_intervals = [\n    (quantile(boot_coefs[:, j], 0.025), quantile(boot_coefs[:, j], 0.975))\n    for j in 1:size(boot_coefs, 2)\n]","category":"page"},{"location":"integration/mixed_models/#Policy-Scenario-Analysis","page":"MixedModels.jl","title":"Policy Scenario Analysis","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"function analyze_policy_scenarios(mixed_model, base_data)\n    compiled = compile_formula(mixed_model, base_data)\n    fixed_coefs = fixef(mixed_model)\n    \n    # Define policy scenarios\n    scenarios = [\n        (\"baseline\", create_scenario(\"baseline\", base_data)),\n        (\"universal_treatment\", create_scenario(\"treatment_all\", base_data; treatment = true)),\n        (\"targeted_treatment\", create_scenario(\"treatment_targeted\", base_data; \n            treatment = true, \n            x = quantile(base_data.x, 0.75)  # Top 25% of x values\n        )),\n        (\"enhanced_policy\", create_scenario(\"enhanced\", base_data;\n            treatment = true,\n            x = mean(base_data.x),\n            additional_support = 1.0  # New policy variable\n        ))\n    ]\n    \n    results = Dict{String, NamedTuple}()\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    for (name, scenario) in scenarios\n        n_obs = Tables.rowcount(scenario.data)\n        predictions = Vector{Float64}(undef, n_obs)\n        \n        for i in 1:n_obs\n            compiled(row_vec, scenario.data, i)\n            predictions[i] = dot(fixed_coefs, row_vec)\n        end\n        \n        results[name] = (\n            mean_outcome = mean(predictions),\n            std_outcome = std(predictions),\n            quantiles = [quantile(predictions, q) for q in [0.25, 0.5, 0.75]]\n        )\n    end\n    \n    return results\nend\n\n# Run analysis\npolicy_results = analyze_policy_scenarios(mixed_model, data)\n\n# Display results\nfor (policy, stats) in policy_results\n    println(\"Policy: $policy\")\n    println(\"  Mean outcome: $(round(stats.mean_outcome, digits=3))\")\n    println(\"  Std outcome: $(round(stats.std_outcome, digits=3))\")\n    println(\"  Quartiles: $(round.(stats.quantiles, digits=3))\")\n    println()\nend","category":"page"},{"location":"integration/mixed_models/#Integration-Notes","page":"MixedModels.jl","title":"Integration Notes","text":"","category":"section"},{"location":"integration/mixed_models/#What's-Included","page":"MixedModels.jl","title":"What's Included","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"Fixed effects terms only\nInteraction terms involving fixed effects\nFunctions applied to fixed effects predictors","category":"page"},{"location":"integration/mixed_models/#What's-Excluded","page":"MixedModels.jl","title":"What's Excluded","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"Random effects terms (1|group), (x|group)\nRandom intercepts and slopes\nCross-level interactions involving random effects","category":"page"},{"location":"integration/mixed_models/#Validation","page":"MixedModels.jl","title":"Validation","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"function validate_mixed_model_integration(mixed_model, data)\n    compiled = compile_formula(mixed_model, data)\n    \n    # Extract fixed effects design matrix from MixedModels.jl\n    mm_fixed = modelmatrix(mixed_model.optsum.lm)\n    \n    # Compare with FormulaCompiler\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    for i in 1:min(10, size(mm_fixed, 1))\n        compiled(row_vec, data, i)\n        original_row = mm_fixed[i, :]\n        \n        if !isapprox(row_vec, original_row, rtol=1e-12)\n            @warn \"Mismatch in row $i\"\n            return false\n        end\n    end\n    \n    println(\"✓ FormulaCompiler matches MixedModels.jl fixed effects matrix\")\n    return true\nend","category":"page"},{"location":"integration/mixed_models/#Best-Practices","page":"MixedModels.jl","title":"Best Practices","text":"","category":"section"},{"location":"integration/mixed_models/#When-to-Use-FormulaCompiler-with-Mixed-Models","page":"MixedModels.jl","title":"When to Use FormulaCompiler with Mixed Models","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"Good use cases:","category":"page"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"Population-level predictions\nFixed effects marginal effects\nPolicy scenario analysis\nBootstrap inference on fixed effects","category":"page"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"Not suitable for:","category":"page"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"Predictions requiring random effects (BLUPs)\nIndividual-level predictions in clustered data\nRandom effects inference\nCross-level interaction effects","category":"page"},{"location":"integration/mixed_models/#Performance-Considerations","page":"MixedModels.jl","title":"Performance Considerations","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"# For repeated evaluations, compile once\nmixed_model = fit(MixedModel, @formula(y ~ x + (1|group)), df)\ncompiled = compile_formula(mixed_model, data)  # Do this once\n\n# Then evaluate many times\nrow_vec = Vector{Float64}(undef, length(compiled))\nfor scenario in many_scenarios\n    for individual in many_individuals\n        compiled(row_vec, scenario.data, individual)\n        # Process fixed effects prediction...\n    end\nend","category":"page"},{"location":"integration/mixed_models/#Memory-Efficiency","page":"MixedModels.jl","title":"Memory Efficiency","text":"","category":"section"},{"location":"integration/mixed_models/","page":"MixedModels.jl","title":"MixedModels.jl","text":"# Mixed models can be large - use scenarios for memory efficiency\nlarge_mixed_model = fit(MixedModel, complex_formula, large_df)\nbase_data = Tables.columntable(large_df)\n\n# Instead of creating many copies of large_df\n# Use scenarios to override just the variables of interest\npolicy_scenario = create_scenario(\"policy\", base_data; \n    key_variable = new_value\n)\n\n# Evaluate with minimal memory overhead\ncompiled = compile_formula(large_mixed_model, base_data)\n# ... use compiled with policy_scenario.data","category":"page"},{"location":"guide/performance/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"This guide covers best practices for achieving maximum performance with FormulaCompiler.jl.","category":"page"},{"location":"guide/performance/#Core-Performance-Principles","page":"Performance Tips","title":"Core Performance Principles","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"FormulaCompiler.jl achieves zero-allocation performance through:","category":"page"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"Compile-time specialization: Move expensive computations to compile time\nType stability: Ensure all operations are type-predictable\nMemory reuse: Pre-allocate and reuse output vectors\nEfficient data structures: Use column tables for optimal access patterns","category":"page"},{"location":"guide/performance/#Runtime-Execution-Flow","page":"Performance Tips","title":"Runtime Execution Flow","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"Here's what happens during each ~50ns evaluation:","category":"page"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"(Image: Diagram)","category":"page"},{"location":"guide/performance/#Pre-compilation-Best-Practices","page":"Performance Tips","title":"Pre-compilation Best Practices","text":"","category":"section"},{"location":"guide/performance/#Compile-Once,-Use-Many-Times","page":"Performance Tips","title":"Compile Once, Use Many Times","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"# Good: Compile once\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\n# Use many times (zero allocations)\nfor i in 1:1_000_000\n    compiled(row_vec, data, i % nrow(data) + 1)\n    # Process result...\nend\n\n# Bad: Compile every time\nfor i in 1:1_000_000\n    result = modelrow(model, data, i % nrow(data) + 1)  # Compiles AND allocates!\nend","category":"page"},{"location":"guide/performance/#Data-Format-Optimization","page":"Performance Tips","title":"Data Format Optimization","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"using Tables, DataFrames\n\ndf = DataFrame(x = randn(10000), y = randn(10000))\n\n# Best: Column table format\ndata = Tables.columntable(df)  # Convert once\ncompiled = compile_formula(model, data)\n\n# Good: Direct DataFrame (but slower)\ncompiled = compile_formula(model, df)\n\n# Benchmark the difference\nusing BenchmarkTools\n\n@benchmark $compiled($row_vec, $data, 1)        # Fastest\n@benchmark $compiled($row_vec, $df, 1)          # Slower due to column access","category":"page"},{"location":"guide/performance/#Memory-Management","page":"Performance Tips","title":"Memory Management","text":"","category":"section"},{"location":"guide/performance/#Pre-allocation-Strategies","page":"Performance Tips","title":"Pre-allocation Strategies","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"# Pre-allocate output vectors\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\n# For batch processing\nn_rows = 1000\nbatch_matrix = Matrix{Float64}(undef, n_rows, length(compiled))\n\n# Reuse across operations\nfor batch_start in 1:n_rows:total_rows\n    batch_end = min(batch_start + n_rows - 1, total_rows)\n    batch_size = batch_end - batch_start + 1\n    \n    # Use view for variable batch sizes\n    batch_view = view(batch_matrix, 1:batch_size, :)\n    modelrow!(batch_view, compiled, data, batch_start:batch_end)\nend","category":"page"},{"location":"guide/performance/#Memory-Layout-Optimization","page":"Performance Tips","title":"Memory Layout Optimization","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"# For repeated operations on the same rows\nfunction optimized_repeated_evaluation(compiled, data, row_indices, n_repetitions)\n    n_rows = length(row_indices)\n    n_cols = length(compiled)\n    \n    # Pre-allocate everything\n    results = Array{Float64, 3}(undef, n_repetitions, n_rows, n_cols)\n    row_vec = Vector{Float64}(undef, n_cols)\n    \n    for rep in 1:n_repetitions\n        for (i, row_idx) in enumerate(row_indices)\n            compiled(row_vec, data, row_idx)\n            results[rep, i, :] .= row_vec\n        end\n    end\n    \n    return results\nend","category":"page"},{"location":"guide/performance/#Benchmarking-and-Profiling","page":"Performance Tips","title":"Benchmarking and Profiling","text":"","category":"section"},{"location":"guide/performance/#Basic-Performance-Testing","page":"Performance Tips","title":"Basic Performance Testing","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"using BenchmarkTools\n\nfunction benchmark_formula_compilation(model, data)\n    # Benchmark compilation\n    compilation_time = @benchmark compile_formula($model, $data)\n    \n    # Benchmark evaluation\n    compiled = compile_formula(model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    evaluation_time = @benchmark $compiled($row_vec, $data, 1)\n    \n    return (compilation = compilation_time, evaluation = evaluation_time)\nend\n\n# Run benchmark\nresults = benchmark_formula_compilation(model, data)\nprintln(\"Compilation: \", results.compilation)\nprintln(\"Evaluation: \", results.evaluation)","category":"page"},{"location":"guide/performance/#Allocation-Detection","page":"Performance Tips","title":"Allocation Detection","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"function check_zero_allocations(compiled, data, n_tests=1000)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    # Warm up\n    compiled(row_vec, data, 1)\n    \n    # Test for allocations\n    allocs_before = Base.gc_alloc_count()\n    \n    for i in 1:n_tests\n        compiled(row_vec, data, i % nrow(data) + 1)\n    end\n    \n    allocs_after = Base.gc_alloc_count()\n    \n    if allocs_after > allocs_before\n        @warn \"Detected $(allocs_after - allocs_before) allocations in $n_tests evaluations\"\n    else\n        println(\"✓ Zero allocations confirmed for $n_tests evaluations\")\n    end\nend\n\ncheck_zero_allocations(compiled, data)","category":"page"},{"location":"guide/performance/#Performance-Profiling","page":"Performance Tips","title":"Performance Profiling","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"using Profile, ProfileView\n\nfunction profile_performance(compiled, data, n_evaluations=100_000)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    # Profile execution\n    Profile.clear()\n    @profile begin\n        for i in 1:n_evaluations\n            compiled(row_vec, data, i % nrow(data) + 1)\n        end\n    end\n    \n    # Analyze results\n    ProfileView.view()  # Opens interactive profile viewer\nend","category":"page"},{"location":"guide/performance/#Formula-Specific-Optimizations","page":"Performance Tips","title":"Formula-Specific Optimizations","text":"","category":"section"},{"location":"guide/performance/#Simple-vs-Complex-Formulas","page":"Performance Tips","title":"Simple vs Complex Formulas","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"# Simple formulas are fastest\nsimple_model = lm(@formula(y ~ x + z), df)\nsimple_compiled = compile_formula(simple_model, data)\n\n# Complex formulas still achieve zero allocation but are slower\ncomplex_model = lm(@formula(y ~ x * group * treatment + log(z) + sqrt(abs(w))), df)\ncomplex_compiled = compile_formula(complex_model, data)\n\n# Benchmark both\n@benchmark $simple_compiled($row_vec, $data, 1)\n@benchmark $complex_compiled($row_vec, $data, 1)","category":"page"},{"location":"guide/performance/#Categorical-Variable-Optimization","page":"Performance Tips","title":"Categorical Variable Optimization","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"using CategoricalArrays\n\n# Ordered categoricals can be more efficient\ndf.ordered_group = categorical(df.group, ordered=true)\n\n# Use efficient contrast coding\ncontrasts_dict = Dict(:group => DummyCoding())\nmodel_with_contrasts = lm(@formula(y ~ x + group), df, contrasts=contrasts_dict)","category":"page"},{"location":"guide/performance/#Function-Optimization-Tips","page":"Performance Tips","title":"Function Optimization Tips","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"# Some functions are more efficient than others\nfast_functions = [\n    @formula(y ~ log(x)),      # Fast\n    @formula(y ~ exp(x)),      # Fast\n    @formula(y ~ sqrt(x)),     # Fast\n    @formula(y ~ x^2),         # Fast\n    @formula(y ~ abs(x))       # Fast\n]\n\nslower_functions = [\n    @formula(y ~ sin(x)),      # Slower\n    @formula(y ~ cos(x)),      # Slower\n    @formula(y ~ x^3.5)        # Slower (non-integer powers)\n]","category":"page"},{"location":"guide/performance/#Large-Dataset-Strategies","page":"Performance Tips","title":"Large Dataset Strategies","text":"","category":"section"},{"location":"guide/performance/#Chunked-Processing","page":"Performance Tips","title":"Chunked Processing","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"function process_large_dataset_efficiently(model, data, chunk_size=10_000)\n    compiled = compile_formula(model, data)\n    n_rows = Tables.rowcount(data)\n    n_cols = length(compiled)\n    \n    # Pre-allocate chunk matrix\n    chunk_matrix = Matrix{Float64}(undef, chunk_size, n_cols)\n    \n    results = Vector{Matrix{Float64}}()\n    \n    for start_idx in 1:chunk_size:n_rows\n        end_idx = min(start_idx + chunk_size - 1, n_rows)\n        actual_chunk_size = end_idx - start_idx + 1\n        \n        # Use view for variable chunk sizes\n        chunk_view = view(chunk_matrix, 1:actual_chunk_size, :)\n        \n        # Zero-allocation batch evaluation\n        modelrow!(chunk_view, compiled, data, start_idx:end_idx)\n        \n        # Store results (this allocates, but unavoidable for storage)\n        push!(results, copy(chunk_view))\n    end\n    \n    return results\nend","category":"page"},{"location":"guide/performance/#Parallel-Processing","page":"Performance Tips","title":"Parallel Processing","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"using Distributed\n\n@everywhere using FormulaCompiler\n\nfunction parallel_formula_evaluation(model, data, row_indices)\n    # Compile on each worker\n    compiled = compile_formula(model, data)\n    \n    # Distributed evaluation\n    results = @distributed (vcat) for row_idx in row_indices\n        row_vec = Vector{Float64}(undef, length(compiled))\n        compiled(row_vec, data, row_idx)\n        row_vec'  # Return as row matrix\n    end\n    \n    return results\nend","category":"page"},{"location":"guide/performance/#Optimization-Anti-patterns","page":"Performance Tips","title":"Optimization Anti-patterns","text":"","category":"section"},{"location":"guide/performance/#What-NOT-to-Do","page":"Performance Tips","title":"What NOT to Do","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"# DON'T: Recompile in loops\nfor i in 1:1000\n    result = modelrow(model, data, i)  # Recompiles every time!\nend\n\n# DON'T: Use DataFrames for row access in tight loops\nfor i in 1:1000\n    compiled(row_vec, df, i)  # Slower than column table\nend\n\n# DON'T: Forget to pre-allocate\nresults = []\nfor i in 1:1000\n    compiled(row_vec, data, i)\n    push!(results, copy(row_vec))  # Allocates and copies!\nend\n\n# DON'T: Create unnecessary temporary arrays\nfor i in 1:1000\n    compiled(row_vec, data, i)\n    result = row_vec .+ 1.0  # Allocates new array!\nend","category":"page"},{"location":"guide/performance/#Better-Alternatives","page":"Performance Tips","title":"Better Alternatives","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"# DO: Compile once, pre-allocate, reuse\ncompiled = compile_formula(model, data)\ndata_table = Tables.columntable(df)\nrow_vec = Vector{Float64}(undef, length(compiled))\nresults = Matrix{Float64}(undef, 1000, length(compiled))\n\nfor i in 1:1000\n    compiled(row_vec, data_table, i)\n    results[i, :] .= row_vec  # In-place assignment\nend\n\n# DO: Use broadcasting for transformations\nresults .+= 1.0  # In-place broadcasting","category":"page"},{"location":"guide/performance/#Performance-Monitoring","page":"Performance Tips","title":"Performance Monitoring","text":"","category":"section"},{"location":"guide/performance/#Continuous-Performance-Testing","page":"Performance Tips","title":"Continuous Performance Testing","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"function performance_regression_test(model, data, target_time_ns=100)\n    compiled = compile_formula(model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    # Warm up\n    compiled(row_vec, data, 1)\n    \n    # Time single evaluation\n    time_ns = @elapsed begin\n        for _ in 1:1000\n            compiled(row_vec, data, 1)\n        end\n    end * 1e9 / 1000  # Convert to ns per evaluation\n    \n    if time_ns > target_time_ns\n        @warn \"Performance regression detected: $(round(time_ns))ns > $(target_time_ns)ns\"\n    else\n        println(\"✓ Performance target met: $(round(time_ns))ns ≤ $(target_time_ns)ns\")\n    end\n    \n    return time_ns\nend","category":"page"},{"location":"guide/performance/#Memory-Usage-Monitoring","page":"Performance Tips","title":"Memory Usage Monitoring","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"function memory_usage_test(model, data)\n    # Measure compilation memory\n    compilation_memory = @allocated compile_formula(model, data)\n    \n    # Measure evaluation memory\n    compiled = compile_formula(model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    \n    evaluation_memory = @allocated compiled(row_vec, data, 1)\n    \n    println(\"Compilation memory: $(compilation_memory) bytes\")\n    println(\"Evaluation memory: $(evaluation_memory) bytes\")\n    \n    if evaluation_memory > 0\n        @warn \"Non-zero allocation in evaluation: $(evaluation_memory) bytes\"\n    end\n    \n    return (compilation = compilation_memory, evaluation = evaluation_memory)\nend","category":"page"},{"location":"guide/performance/#Real-world-Performance-Examples","page":"Performance Tips","title":"Real-world Performance Examples","text":"","category":"section"},{"location":"guide/performance/#Monte-Carlo-Simulation","page":"Performance Tips","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"function efficient_monte_carlo(model, data, n_simulations=1_000_000)\n    compiled = compile_formula(model, data)\n    row_vec = Vector{Float64}(undef, length(compiled))\n    results = Vector{Float64}(undef, n_simulations)\n    \n    # Pre-compute random indices\n    row_indices = rand(1:nrow(data), n_simulations)\n    \n    @time begin\n        for i in 1:n_simulations\n            compiled(row_vec, data, row_indices[i])\n            results[i] = some_statistic(row_vec)  # Your analysis function\n        end\n    end\n    \n    return results\nend","category":"page"},{"location":"guide/performance/#Bootstrap-Resampling","page":"Performance Tips","title":"Bootstrap Resampling","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"function efficient_bootstrap(model, data, n_bootstrap=1000)\n    compiled = compile_formula(model, data)\n    n_rows = nrow(data)\n    n_cols = length(compiled)\n    \n    bootstrap_results = Matrix{Float64}(undef, n_bootstrap, n_cols)\n    row_vec = Vector{Float64}(undef, n_cols)\n    \n    for boot in 1:n_bootstrap\n        # Generate bootstrap sample indices\n        sample_indices = rand(1:n_rows, n_rows)\n        \n        # Compute bootstrap statistic\n        for (i, row_idx) in enumerate(sample_indices)\n            compiled(row_vec, data, row_idx)\n            if i == 1\n                bootstrap_results[boot, :] .= row_vec\n            else\n                bootstrap_results[boot, :] .+= row_vec\n            end\n        end\n        \n        bootstrap_results[boot, :] ./= n_rows  # Average\n    end\n    \n    return bootstrap_results\nend","category":"page"},{"location":"guide/performance/#Summary","page":"Performance Tips","title":"Summary","text":"","category":"section"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"Key performance guidelines:","category":"page"},{"location":"guide/performance/","page":"Performance Tips","title":"Performance Tips","text":"Compile once: Never recompile formulas in loops\nPre-allocate: Create output vectors once and reuse\nUse column tables: Convert DataFrames to Tables.columntable format\nProfile regularly: Monitor for performance regressions\nBatch when possible: Use modelrow! for multiple rows","category":"page"},{"location":"#FormulaCompiler.jl","page":"Home","title":"FormulaCompiler.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High-performance, zero-allocation model matrix evaluation for Julia statistical models. Works across all formula types through advanced compile-time specialization.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Zero allocations: ~50ns per row, 0 bytes allocated across all 2032 test cases\nSignificant speedup and efficiency over modelmatrix() for single-row evaluations  \nUniversal compatibility: Handles any valid StatsModels.jl formula, including complex interactions and functions\nAdvanced scenarios: Memory-efficient variable overrides for policy analysis\nUnified architecture: Single compilation pipeline handles all formula complexities\nFull ecosystem support: Works with GLM.jl, MixedModels.jl, StandardizedPredictors.jl\nDual-backend derivatives: Zero-allocation finite differences OR ForwardDiff (~368 bytes per call)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/emfeltham/FormulaCompiler.jl\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Workflow)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure: Basic FormulaCompiler.jl workflow - from statistical model to zero-allocation evaluation","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FormulaCompiler, GLM, DataFrames, Tables\n\n# Fit your model normally\ndf = DataFrame(\n    y = randn(1000),\n    x = randn(1000),\n    z = abs.(randn(1000)) .+ 0.1,\n    group = categorical(rand([\"A\", \"B\", \"C\"], 1000))\n)\n\nmodel = lm(@formula(y ~ x * group + log(z)), df)\n\n# Compile once for fast evaluation  \ndata = Tables.columntable(df)\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\n# Zero-allocation evaluation (call millions of times)\ncompiled(row_vec, data, 1)  # ~50ns, 0 allocations","category":"page"},{"location":"#Performance-Comparison","page":"Home","title":"Performance Comparison","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Performance results across all tested formula types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BenchmarkTools\n\n# Traditional approach (creates full model matrix)\n@benchmark modelmatrix(model)[1, :]\n# ~10.2 μs (1 allocation: 896 bytes)\n\n# FormulaCompiler (zero-allocation single row)\ndata = Tables.columntable(df)\ncompiled = compile_formula(model, data)\nrow_vec = Vector{Float64}(undef, length(compiled))\n\n@benchmark compiled(row_vec, data, 1)\n# ~50 ns (0 allocations: 0 bytes)\n\n# Zero allocation across 2032 test cases","category":"page"},{"location":"#Allocation-Characteristics","page":"Home","title":"Allocation Characteristics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FormulaCompiler.jl provides different allocation guarantees depending on the operation:","category":"page"},{"location":"#Core-Model-Evaluation","page":"Home","title":"Core Model Evaluation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Perfect zero allocations: modelrow!() and direct compiled() calls are guaranteed 0 bytes after warmup\nPerformance: ~50ns per row across all formula complexities\nValidated: 2032+ test cases confirm zero-allocation performance","category":"page"},{"location":"#Derivative-Operations","page":"Home","title":"Derivative Operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FormulaCompiler.jl offers dual backends for derivatives and marginal effects:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backend Allocations Performance Use Case\n:fd (Finite Differences) 0 bytes ~79ns Strict zero-allocation requirements\n:ad (ForwardDiff) ~368-400 bytes ~508ns Speed and numerical accuracy priority","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Choose your backend based on requirements\nmarginal_effects_eta!(g, de, beta, row; backend=:fd)  # 0 allocations\nmarginal_effects_eta!(g, de, beta, row; backend=:ad)  # ~368 bytes, faster","category":"page"},{"location":"#When-to-Use-Each-Backend","page":"Home","title":"When to Use Each Backend","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use :fd for: Monte Carlo loops, bootstrap resampling, memory-constrained environments\nUse :ad for: One-off calculations, interactive analysis, maximum numerical precision","category":"page"},{"location":"#Use-Cases","page":"Home","title":"Use Cases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Monte Carlo simulations: Millions of model evaluations\nBootstrap resampling: Repeated matrix construction\nMarginal effects: Choose zero-allocation finite differences or faster ForwardDiff\nPolicy analysis: Evaluate many counterfactual scenarios\nReal-time applications: Low-latency prediction serving\nLarge-scale inference: Memory-efficient batch processing","category":"page"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Read the Getting Started guide for a detailed walkthrough\nExplore Advanced Features for scenario analysis and memory optimization\nCheck out Examples for real-world use cases\nReview the Mathematical Foundation for comprehensive theory and implementation details\nReview the API Reference for complete function documentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Built for the Julia statistical ecosystem. Optimized for performance, designed for usability.","category":"page"}]
}
