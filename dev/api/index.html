<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · FormulaCompiler.jl</title><meta name="title" content="API Reference · FormulaCompiler.jl"/><meta property="og:title" content="API Reference · FormulaCompiler.jl"/><meta property="twitter:title" content="API Reference · FormulaCompiler.jl"/><meta name="description" content="Documentation for FormulaCompiler.jl."/><meta property="og:description" content="Documentation for FormulaCompiler.jl."/><meta property="twitter:description" content="Documentation for FormulaCompiler.jl."/><meta property="og:url" content="https://emfeltham.github.io/FormulaCompiler.jl/api/"/><meta property="twitter:url" content="https://emfeltham.github.io/FormulaCompiler.jl/api/"/><link rel="canonical" href="https://emfeltham.github.io/FormulaCompiler.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/mermaid.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FormulaCompiler.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../guide/basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../guide/advanced_features/">Advanced Features</a></li><li><a class="tocitem" href="../guide/categorical_mixtures/">Categorical Mixtures</a></li><li><a class="tocitem" href="../guide/scenarios/">Scenario Analysis</a></li><li><a class="tocitem" href="../guide/performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../integration/glm/">GLM.jl</a></li><li><a class="tocitem" href="../integration/mixed_models/">MixedModels.jl</a></li><li><a class="tocitem" href="../integration/standardized_predictors/">StandardizedPredictors.jl</a></li></ul></li><li><a class="tocitem" href="../mathematical_foundation/">Mathematical Foundation</a></li><li><a class="tocitem" href="../architecture/">Architecture</a></li><li><a class="tocitem" href="../metaprogramming/">Metaprogramming</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Core-Compilation-Functions"><span>Core Compilation Functions</span></a></li><li><a class="tocitem" href="#Model-Row-Evaluation"><span>Model Row Evaluation</span></a></li><li><a class="tocitem" href="#Derivatives"><span>Derivatives</span></a></li><li><a class="tocitem" href="#Categorical-Contrasts"><span>Categorical Contrasts</span></a></li><li><a class="tocitem" href="#Categorical-Mixtures"><span>Categorical Mixtures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/emfeltham/FormulaCompiler.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>API reference for FormulaCompiler.jl functions and types.</p><h2 id="Core-Compilation-Functions"><a class="docs-heading-anchor" href="#Core-Compilation-Functions">Core Compilation Functions</a><a id="Core-Compilation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Compilation-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.compile_formula" href="#FormulaCompiler.compile_formula"><code>FormulaCompiler.compile_formula</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compile_formula(model, data) -&gt; UnifiedCompiled</code></pre><p>Compile a fitted statistical model into a zero-allocation, type-specialized evaluator.</p><p>Transforms statistical formulas into optimized computational engines using position mapping that achieves ~50ns per row evaluation with zero allocations. The resulting evaluator provides constant-time row access regardless of dataset size.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Fitted statistical model (<code>GLM.LinearModel</code>, <code>GLM.GeneralizedLinearModel</code>,          <code>MixedModels.LinearMixedModel</code>, etc.)</li><li><code>data</code>: Data in Tables.jl format (preferably <code>Tables.columntable(df)</code> for optimal performance)</li></ul><p><strong>Returns</strong></p><ul><li><code>UnifiedCompiled{T,Ops,S,O}</code>: Callable evaluator with embedded position mappings<ul><li>Call as <code>compiled(output_vector, data, row_index)</code> for zero-allocation evaluation</li><li><code>length(compiled)</code> returns number of model matrix columns</li></ul></li></ul><p><strong>Performance Characteristics</strong></p><ul><li><strong>Compilation</strong>: One-time cost for complex formulas</li><li><strong>Evaluation</strong>: Zero bytes allocated after warmup</li><li><strong>Memory</strong>: O(output_size) scratch space, reused across all evaluations</li><li><strong>Scaling</strong>: Evaluation time independent of dataset size</li></ul><p><strong>Supported Models</strong></p><ul><li>Linear models: <code>GLM.lm(@formula(y ~ x + group), df)</code></li><li>Generalized linear models: <code>GLM.glm(@formula(success ~ x), df, Binomial(), LogitLink())</code></li><li>Mixed models: <code>MixedModels.fit(MixedModel, @formula(y ~ x + (1|group)), df)</code> (fixed effects only)</li><li>Custom contrasts: Models with <code>DummyCoding()</code>, <code>EffectsCoding()</code>, <code>HelmertCoding()</code>, etc.</li><li>Standardized predictors: Models with <code>ZScore()</code> standardization</li></ul><p><strong>Formula Features</strong></p><ul><li><strong>Basic terms</strong>: <code>x</code>, <code>log(z)</code>, <code>x^2</code>, <code>(x &gt; 0)</code>, integer and float variables</li><li><strong>Categorical variables</strong>: Must use <code>CategoricalArrays.jl</code> format - raw strings not supported</li><li><strong>Interactions</strong>: <code>x * group</code>, <code>x * y * z</code>, <code>log(x) * group</code></li><li><strong>Functions</strong>: <code>log</code>, <code>exp</code>, <code>sqrt</code>, <code>sin</code>, <code>cos</code>, <code>abs</code>, <code>^</code> (integer and fractional powers)</li><li><strong>Boolean conditions</strong>: <code>(x &gt; 0)</code>, <code>(z &gt;= mean(z))</code>, <code>(group == &quot;A&quot;)</code></li><li><strong>Complex formulas</strong>: <code>x * log(abs(z)) * group + sqrt(y) + (w &gt; threshold)</code></li></ul><p><strong>Data Requirements</strong></p><ul><li><strong>Categorical variables</strong>: Must use <code>categorical(column)</code> before model fitting</li><li><strong>Missing values</strong>: Not supported - remove with <code>dropmissing()</code> or impute before compilation</li><li><strong>Table format</strong>: Use <code>Tables.columntable(df)</code> for optimal performance</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using FormulaCompiler, GLM, DataFrames, Tables, CategoricalArrays

# Fit model
df = DataFrame(
    y = randn(1000), 
    x = randn(1000), 
    group = categorical(rand([&quot;A&quot;, &quot;B&quot;], 1000))  # Required: use categorical()
)
model = lm(@formula(y ~ x * group + log(abs(x) + 1)), df)

# Compile once
data = Tables.columntable(df)  # Convert for optimal performance
compiled = compile_formula(model, data)

# Use many times (zero allocations)
output = Vector{Float64}(undef, length(compiled))
compiled(output, data, 1)     # Zero allocations
compiled(output, data, 500)   # Zero allocations

# Substantial speedup compared to modelmatrix(model)[row, :]</code></pre><p><strong>Mixed Models Example</strong></p><pre><code class="language-julia hljs">using MixedModels
mixed = fit(MixedModel, @formula(y ~ x + treatment + (1|subject)), df)
compiled = compile_formula(mixed, data)  # Compiles fixed effects: y ~ x + treatment</code></pre><p>See also: <a href="#FormulaCompiler.modelrow!"><code>modelrow!</code></a>, <a href="#FormulaCompiler.ModelRowEvaluator"><code>ModelRowEvaluator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/compilation.jl#L26-L103">source</a></section><section><div><pre><code class="language-julia hljs">compile_formula(formula::StatsModels.FormulaTerm, data) -&gt; UnifiedCompiled</code></pre><p>Compile a formula directly without a fitted model for zero-allocation evaluation.</p><p>This overload enables compilation from raw formulas, bypassing model fitting when only the computational structure is needed. Useful for custom model implementations or direct formula evaluation workflows.</p><p><strong>Arguments</strong></p><ul><li><code>formula::StatsModels.FormulaTerm</code>: Formula specification (e.g., from <code>@formula(y ~ x + group)</code>)</li><li><code>data</code>: Data in Tables.jl format (preferably <code>Tables.columntable(df)</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>UnifiedCompiled{T,Ops,S,O}</code>: Zero-allocation evaluator, same interface as model-based compilation</li></ul><p><strong>Performance</strong></p><ul><li><strong>Compilation</strong>: Fast for complex formulas</li><li><strong>Evaluation</strong>: Zero bytes allocated</li><li><strong>Memory</strong>: Identical performance to model-based compilation</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using StatsModels, FormulaCompiler, Tables

# Direct formula compilation
formula = @formula(y ~ x * group + log(z))
data = Tables.columntable(df)
compiled = compile_formula(formula, data)

# Zero-allocation evaluation
output = Vector{Float64}(undef, length(compiled))
compiled(output, data, 1)  # Zero allocations</code></pre><p><strong>Use Cases</strong></p><ul><li>Custom model implementations requiring direct formula evaluation</li><li>Performance-critical applications avoiding model fitting overhead</li><li>Exploratory analysis with formula variations</li><li>Integration with external statistical frameworks</li></ul><p>See also: <a href="#FormulaCompiler.compile_formula"><code>compile_formula(model, data)</code></a> for model-based compilation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/compilation.jl#L125-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.get_or_compile_formula" href="#FormulaCompiler.get_or_compile_formula"><code>FormulaCompiler.get_or_compile_formula</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_or_compile_formula(model, data)</code></pre><p>Get cached compiled formula or compile new one with semantic type-aware caching.</p><p><strong>Cache Key Strategy</strong></p><p>Creates cache key based on:</p><ol><li>Model object (coefficients, structure)</li><li>Column names (formula structure)</li><li>Semantic type categories (compilation behavior)</li></ol><p><strong>Type Category Benefits</strong></p><ul><li><strong>Better cache hits</strong>: Vector{Int} and Vector{Float64} share cache entry</li><li><strong>Correct mixture handling</strong>: CategoricalArray vs CategoricalMixture distinguished</li><li><strong>Future-proof</strong>: New types can be added to category system</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># These share a cache entry (both :numeric):
data1 = (x = Float64[1.0, 2.0], y = ...)
data2 = (x = Int[1, 2], y = ...)  # Cache HIT ✓

# These get separate entries (different compilation):
data3 = (edu = categorical([&quot;HS&quot;]), ...)      # :categorical
data4 = (edu = mix(&quot;HS&quot; =&gt; 0.5, &quot;C&quot; =&gt; 0.5), ...)  # :mixture - Cache MISS ✓</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/modelrow.jl#L66-L92">source</a></section></article><h2 id="Model-Row-Evaluation"><a class="docs-heading-anchor" href="#Model-Row-Evaluation">Model Row Evaluation</a><a id="Model-Row-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Row-Evaluation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.modelrow" href="#FormulaCompiler.modelrow"><code>FormulaCompiler.modelrow</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modelrow(model, data, row_idx) -&gt; Vector{Float64}</code></pre><p>Evaluate a single model matrix row, returning a new vector (allocating version).</p><p>Convenient interface for when pre-allocation is not practical. Uses internal formula compilation and caching for performance optimization, though the non-allocating <code>modelrow!</code> interface is preferred for performance-critical code.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Fitted statistical model (GLM, MixedModel, etc.)</li><li><code>data</code>: Data in Tables.jl format </li><li><code>row_idx::Int</code>: Row index to evaluate (1-based)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: New vector containing model matrix row values</li></ul><p><strong>Performance</strong></p><ul><li><strong>First call</strong>: Includes one-time compilation cost</li><li><strong>Subsequent calls</strong>: Fast evaluation plus allocation cost for vector creation</li><li><strong>Memory</strong>: Allocates new vector each call</li><li><strong>Caching</strong>: Automatically caches compiled formula for reuse</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using FormulaCompiler, GLM

model = lm(@formula(y ~ x * group + log(z)), df)
data = Tables.columntable(df)

# Convenient single-row evaluation
row_1 = modelrow(model, data, 1)      # First call (includes compilation)
row_2 = modelrow(model, data, 2)      # Subsequent calls (uses cached compilation)
row_100 = modelrow(model, data, 100)  # Fast (uses cached compilation)</code></pre><p><strong>When to Use</strong></p><ul><li><strong>Prototyping</strong>: Quick analysis and exploration</li><li><strong>Small datasets</strong>: When allocation overhead is negligible</li><li><strong>Convenience</strong>: When code simplicity outweighs performance requirements</li></ul><p><strong>Performance Alternative</strong></p><p>For zero-allocation performance in loops, use <a href="#FormulaCompiler.modelrow!"><code>modelrow!</code></a>:</p><pre><code class="language-julia hljs">output = Vector{Float64}(undef, length(compile_formula(model, data)))
for i in 1:n_iterations
    modelrow!(output, compiled, data, i)  # Zero allocations each iteration
end</code></pre><p>See also: <a href="#FormulaCompiler.modelrow!"><code>modelrow!</code></a>, <a href="#FormulaCompiler.ModelRowEvaluator"><code>ModelRowEvaluator</code></a>, <a href="#FormulaCompiler.compile_formula"><code>compile_formula</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/modelrow.jl#L468-L519">source</a></section><section><div><pre><code class="language-julia hljs">modelrow(model, data, row_indices) -&gt; Matrix{Float64}</code></pre><p>Evaluate multiple rows and return a new matrix (allocating version). Uses compiled formulas for optimal performance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">matrix = modelrow(model, data, [1, 5, 10])  # Returns Matrix{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/modelrow.jl#L527-L537">source</a></section><section><div><pre><code class="language-julia hljs">modelrow(compiled_formula, data, row_idx) -&gt; Vector{Float64}</code></pre><p>Evaluate a single row with pre-compiled compiled formula.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">compiled = compile_formula(model, data)
row_values = modelrow(compiled, data, 1)  # Returns Vector{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/modelrow.jl#L545-L555">source</a></section><section><div><pre><code class="language-julia hljs">modelrow(compiled_formula, data, row_indices) -&gt; Matrix{Float64}</code></pre><p>Evaluate multiple rows with pre-compiled compiled formula.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">compiled = compile_formula(model, data)
matrix = modelrow(compiled, data, [1, 5, 10])  # Returns Matrix{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/modelrow.jl#L566-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.modelrow!" href="#FormulaCompiler.modelrow!"><code>FormulaCompiler.modelrow!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modelrow!(output, compiled, data, row_idx) -&gt; output</code></pre><p>Evaluate a single model matrix row in-place with zero allocations.</p><p>The primary interface for high-performance row evaluation. This function provides zero-allocation evaluation, making it suitable for tight computational loops and performance-critical applications.</p><p><strong>Arguments</strong></p><ul><li><code>output::AbstractVector{Float64}</code>: Pre-allocated output vector (modified in-place)<ul><li>Must have length ≥ <code>length(compiled)</code></li><li>Contents will be overwritten with model matrix row values</li></ul></li><li><code>compiled</code>: Compiled formula from <code>compile_formula(model, data)</code></li><li><code>data</code>: Data in Tables.jl format (preferably <code>Tables.columntable(df)</code> for best performance)</li><li><code>row_idx::Int</code>: Row index to evaluate (1-based indexing)</li></ul><p><strong>Returns</strong></p><ul><li><code>output</code>: The same vector passed in, now containing the evaluated model matrix row</li></ul><p><strong>Performance</strong></p><ul><li><strong>Memory</strong>: Zero bytes allocated after warmup</li><li><strong>Scaling</strong>: Constant time regardless of dataset size or formula complexity</li><li><strong>Validation</strong>: Tested across 2000+ diverse formula configurations</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using FormulaCompiler, GLM, Tables

# Setup (one-time cost)
model = lm(@formula(y ~ x * group + log(z)), df)
data = Tables.columntable(df)
compiled = compile_formula(model, data)
output = Vector{Float64}(undef, length(compiled))

# High-performance evaluation (repeated many times)
modelrow!(output, compiled, data, 1)    # Zero allocations
modelrow!(output, compiled, data, 100)  # Zero allocations

# Monte Carlo simulation example
for i in 1:1_000_000
    row_idx = rand(1:nrow(df))
    modelrow!(output, compiled, data, row_idx)  # Zero allocations each call
    # Process output...
end</code></pre><p><strong>Error Handling</strong></p><ul><li><code>BoundsError</code>: If <code>row_idx</code> exceeds data size</li><li><code>DimensionMismatch</code>: If <code>output</code> vector is too small</li><li>Validates arguments in debug builds</li></ul><p>See also: <a href="#FormulaCompiler.modelrow"><code>modelrow</code></a> for allocating version, <a href="#FormulaCompiler.compile_formula"><code>compile_formula</code></a>, <a href="#FormulaCompiler.ModelRowEvaluator"><code>ModelRowEvaluator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/modelrow.jl#L110-L163">source</a></section><section><div><pre><code class="language-julia hljs">modelrow!(row_vec, model, data, row_idx; cache=true)</code></pre><p>Evaluate a single row of the model matrix in-place with automatic compilation.</p><p><strong>Arguments</strong></p><ul><li><code>row_vec::AbstractVector{Float64}</code>: Pre-allocated output vector (modified in-place)</li><li><code>model</code>: Statistical model (GLM, MixedModel, etc.)</li><li><code>data</code>: Data in Tables.jl format</li><li><code>row_idx::Int</code>: Row index to evaluate</li><li><code>cache::Bool</code>: Whether to cache compiled formula (default: true)</li></ul><p><strong>Returns</strong></p><ul><li><code>row_vec</code>: The same vector passed in, now containing the evaluated row</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = lm(@formula(y ~ x + group), df)
data = Tables.columntable(df)
row_vec = Vector{Float64}(undef, size(modelmatrix(model), 2))
modelrow!(row_vec, model, data, 1)</code></pre><div class="admonition is-info" id="Note-a2d3dcbdd22cc036"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a2d3dcbdd22cc036" title="Permalink"></a></header><div class="admonition-body"><p>First call compiles the formula. Subsequent calls reuse cached version when <code>cache=true</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/modelrow.jl#L177-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.ModelRowEvaluator" href="#FormulaCompiler.ModelRowEvaluator"><code>FormulaCompiler.ModelRowEvaluator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModelRowEvaluator{T,Ops,S,O}</code></pre><p>Object-oriented interface for reusable, pre-compiled model evaluation.</p><p>Combines compiled formula, data, and output buffer into a single object that can be called repeatedly for both allocating and non-allocating row evaluation. Useful when the same model and data will be evaluated many times.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Element type (typically <code>Float64</code>)</li><li><code>Ops</code>: Compiled operations tuple type</li><li><code>S</code>: Scratch buffer size </li><li><code>O</code>: Output vector size</li></ul><p><strong>Fields</strong></p><ul><li><code>compiled::UnifiedCompiled</code>: Pre-compiled formula</li><li><code>data::NamedTuple</code>: Data in column-table format</li><li><code>row_vec::Vector{Float64}</code>: Internal buffer for non-allocating calls</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ModelRowEvaluator(model, df::DataFrame)      # Converts DataFrame to column table
ModelRowEvaluator(model, data::NamedTuple)   # Uses data directly</code></pre><p><strong>Interface</strong></p><pre><code class="language-julia hljs"># Allocating interface - returns new vector
result = evaluator(row_idx)

# Non-allocating interface - uses provided vector  
evaluator(output_vector, row_idx)</code></pre><p><strong>Performance</strong></p><ul><li><strong>Construction</strong>: One-time compilation cost</li><li><strong>Allocating calls</strong>: Fast evaluation plus allocation cost</li><li><strong>Non-allocating calls</strong>: Zero bytes allocated</li><li><strong>Memory</strong>: Minimal overhead beyond compiled formula and data reference</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using FormulaCompiler, GLM

# Create evaluator (one-time setup)
model = lm(@formula(y ~ x * group + log(z)), df)
evaluator = ModelRowEvaluator(model, df)

# Allocating interface (convenient)
row_1 = evaluator(1)      # Returns Vector{Float64}
row_2 = evaluator(100)    # Returns Vector{Float64}

# Non-allocating interface (fast)
output = Vector{Float64}(undef, length(evaluator))
evaluator(output, 1)      # Zero allocations
evaluator(output, 100)    # Zero allocations

# Batch processing
results = Matrix{Float64}(undef, 1000, length(evaluator))
for i in 1:1000
    evaluator(view(results, i, :), i)  # Zero allocations
end</code></pre><p><strong>When to Use</strong></p><ul><li><strong>Repeated evaluation</strong>: Same model and data used many times</li><li><strong>Object-oriented style</strong>: Prefer objects over function calls</li><li><strong>Mixed interfaces</strong>: Need both allocating and non-allocating evaluation</li><li><strong>Clean encapsulation</strong>: Bundle model, data, and buffer management</li></ul><p>See also: <a href="#FormulaCompiler.modelrow!"><code>modelrow!</code></a>, <a href="#FormulaCompiler.modelrow"><code>modelrow</code></a>, <a href="#FormulaCompiler.compile_formula"><code>compile_formula</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/modelrow.jl#L224-L296">source</a></section></article><h2 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h2><p>FormulaCompiler provides computational primitives for computing derivatives of model matrix rows with respect to continuous variables. These functions enable zero-allocation Jacobian computation using either automatic differentiation (ForwardDiff) or finite differences.</p><p>For marginal effects, standard errors, and complete statistical workflows, see <a href="https://github.com/emfeltham/Margins.jl">Margins.jl</a>.</p><h3 id="Evaluator-Construction"><a class="docs-heading-anchor" href="#Evaluator-Construction">Evaluator Construction</a><a id="Evaluator-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluator-Construction" title="Permalink"></a></h3><p><strong>Recommended</strong>: Use the unified dispatcher for user-facing code:</p><pre><code class="language-julia hljs"># Automatic differentiation (preferred)
de = derivativeevaluator(:ad, compiled, data, [:x, :z])

# Finite differences
de = derivativeevaluator(:fd, compiled, data, [:x, :z])</code></pre><p><strong>Advanced</strong>: Direct constructor functions (primarily for internal use):</p><div class="admonition is-warning" id="Missing-docstring.-1ab2fe394b31391c"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-1ab2fe394b31391c" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>derivativeevaluator</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.derivativeevaluator_fd" href="#FormulaCompiler.derivativeevaluator_fd"><code>FormulaCompiler.derivativeevaluator_fd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivativeevaluator_fd(compiled, data, vars) -&gt; FDEvaluator</code></pre><p>Create a finite differences specialized FDEvaluator using Float64 counterfactual vectors.</p><p>Returns a concrete FDEvaluator with only FD infrastructure, no field pollution from AD. Uses NumericCounterfactualVector{Float64} for type-stable counterfactual operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/derivatives/evaluator.jl#L128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.derivativeevaluator_ad" href="#FormulaCompiler.derivativeevaluator_ad"><code>FormulaCompiler.derivativeevaluator_ad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivativeevaluator_ad(compiled, data, vars) -&gt; ADEvaluator</code></pre><p>Create an automatic differentiation specialized ADEvaluator using Dual counterfactual vectors.</p><p>Returns a concrete ADEvaluator with only AD infrastructure, no field pollution from FD. Uses NumericCounterfactualVector{Dual{...}} for type-stable dual number operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/derivatives/evaluator.jl#L167-L174">source</a></section></article><h3 id="Jacobian-Computation"><a class="docs-heading-anchor" href="#Jacobian-Computation">Jacobian Computation</a><a id="Jacobian-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-Computation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.derivative_modelrow!" href="#FormulaCompiler.derivative_modelrow!"><code>FormulaCompiler.derivative_modelrow!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative_modelrow!(J, de::ADEvaluator, row) -&gt; J</code></pre><p>Primary automatic differentiation API - zero allocations via ForwardDiff.jacobian!.</p><p>Phase 2 implementation using cached ForwardDiff configuration for zero allocations. Replaces manual dual construction with ForwardDiff&#39;s optimized jacobian! routine.</p><p><strong>Arguments</strong></p><ul><li><code>J::AbstractMatrix{Float64}</code>: Preallocated Jacobian buffer of size <code>(n_terms, n_vars)</code></li><li><code>de::ADEvaluator</code>: AD evaluator built by <code>derivativeevaluator(:ad, compiled, data, vars)</code></li><li><code>row::Int</code>: Row index to evaluate (1-based indexing)</li></ul><p><strong>Returns</strong></p><ul><li><code>J</code>: The same matrix passed in, now containing <code>J[i,j] = ∂X[i]/∂vars[j]</code> for the specified row</li></ul><p><strong>Performance Characteristics (Phase 2)</strong></p><ul><li><strong>Memory</strong>: 0 bytes allocated (cached buffers and ForwardDiff config)</li><li><strong>Speed</strong>: Target ~60ns with ForwardDiff.jacobian! optimization</li><li><strong>Accuracy</strong>: Machine precision derivatives via ForwardDiff dual arithmetic</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using FormulaCompiler, GLM

# Setup model
model = lm(@formula(y ~ x + z), df)
data = Tables.columntable(df)
compiled = compile_formula(model, data)

# Build AD evaluator
de = derivativeevaluator(:ad, compiled, data, [:x, :z])

# Zero-allocation Jacobian computation
J = Matrix{Float64}(undef, length(compiled), length(de.vars))
derivative_modelrow!(J, de, 1)  # 0 bytes allocated</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/derivatives/automatic_diff.jl#L4-L41">source</a></section><section><div><pre><code class="language-julia hljs">derivative_modelrow!(J, de::FDEvaluator, row) -&gt; J</code></pre><p>Primary finite differences API - zero allocations, concrete type dispatch.</p><p>Computes full Jacobian matrix ∂X[i]/∂vars[j] using central differences with adaptive step sizing. Matches automatic_diff.jl signature for seamless backend switching.</p><p><strong>Performance Characteristics</strong></p><ul><li><strong>Memory</strong>: 0 bytes allocated (uses pre-allocated FDEvaluator buffers)</li><li><strong>Speed</strong>: ~65ns per variable with mathematical optimizations</li><li><strong>Accuracy</strong>: Adaptive step sizing balances truncation/roundoff error</li></ul><p><strong>Mathematical Method</strong></p><p>Central differences: ∂f/∂x ≈ [f(x+h) - f(x-h)] / (2h) Step sizing: h = ε^(1/3) * max(1, |x|) for numerical stability</p><p><strong>Arguments</strong></p><ul><li><code>J::AbstractMatrix{Float64}</code>: Pre-allocated Jacobian buffer of size <code>(n_terms, n_vars)</code></li><li><code>de::FDEvaluator</code>: Pre-built evaluator from <code>derivativeevaluator_fd(compiled, data, vars)</code></li><li><code>row::Int</code>: Row index to evaluate (1-based indexing)</li></ul><p><strong>Returns</strong></p><ul><li><code>J</code>: The same matrix passed in, containing <code>J[i,j] = ∂X[i]/∂vars[j]</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using FormulaCompiler, GLM

# Setup model and data
model = lm(@formula(y ~ x * group + log(abs(z) + 1)), df)
data = Tables.columntable(df)
compiled = compile_formula(model, data)

# Build FD evaluator
de_fd = derivativeevaluator_fd(compiled, data, [:x, :z])

# Zero-allocation finite differences
J = Matrix{Float64}(undef, length(compiled), length(de_fd.vars))
derivative_modelrow!(J, de_fd, 1)  # 0 bytes allocated</code></pre><p>See also: <a href="#FormulaCompiler.derivativeevaluator_fd"><code>derivativeevaluator_fd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/evaluation/derivatives/finite_diff.jl#L6-L49">source</a></section></article><div class="admonition is-warning" id="Missing-docstring.-e124615fd84bf70e"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-e124615fd84bf70e" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>derivative_modelrow</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Variable-Identification"><a class="docs-heading-anchor" href="#Variable-Identification">Variable Identification</a><a id="Variable-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Identification" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.continuous_variables" href="#FormulaCompiler.continuous_variables"><code>FormulaCompiler.continuous_variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">continuous_variables(compiled, data) -&gt; Vector{Symbol}</code></pre><p>Identify continuous variables suitable for derivative computation from a compiled formula.</p><p>Analyzes compiled operations to distinguish between continuous variables (suitable for differentiation) and categorical variables (requiring discrete analysis). Essential for determining valid variable sets for derivative evaluators and marginal effects computation.</p><p><strong>Arguments</strong></p><ul><li><code>compiled::UnifiedCompiled</code>: Compiled formula from <code>compile_formula(model, data)</code>  </li><li><code>data::NamedTuple</code>: Data in column-table format (from <code>Tables.columntable(df)</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Symbol}</code>: Sorted list of continuous variable names<ul><li>Includes: Float64, Int64, Int32, Int variables used in LoadOp operations</li><li>Excludes: Variables appearing only in ContrastOp operations (categorical contrasts)</li><li>Excludes: Boolean variables (treated as categorical regardless of numeric type)</li></ul></li></ul><p><strong>Classification Algorithm</strong></p><ol><li><strong>Operation analysis</strong>: Scan compiled operations for LoadOp vs ContrastOp usage</li><li><strong>Type filtering</strong>: Verify variables have Real element types in data</li><li><strong>Boolean exclusion</strong>: Remove Bool variables (categorical by convention)</li><li><strong>Categorical exclusion</strong>: Remove variables only appearing in contrast operations</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">using FormulaCompiler, GLM, CategoricalArrays

# Mixed variable types
df = DataFrame(
    y = randn(1000),
    price = randn(1000),          # Float64 - continuous
    quantity = rand(1:100, 1000), # Int64 - continuous
    available = rand(Bool, 1000), # Bool - categorical
    category = categorical(rand([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], 1000))  # Categorical - categorical
)

model = lm(@formula(y ~ price + quantity + available + category), df)
compiled = compile_formula(model, Tables.columntable(df))

# Identify continuous variables
continuous_vars = continuous_variables(compiled, Tables.columntable(df))
# Returns: [:price, :quantity]

# Use for derivative evaluator construction
de_fd = derivativeevaluator_fd(compiled, Tables.columntable(df), continuous_vars)
de_ad = derivativeevaluator_ad(compiled, Tables.columntable(df), continuous_vars)</code></pre><p><strong>Use Cases</strong></p><ul><li><strong>Pre-validation</strong>: Check variable suitability before building derivative evaluators</li><li><strong>Automatic selection</strong>: Programmatically identify all differentiable variables</li><li><strong>Error prevention</strong>: Avoid attempting derivatives on categorical variables</li><li><strong>Model introspection</strong>: Understand variable roles in compiled formulas</li></ul><p><strong>Implementation Details</strong></p><ul><li>Scans LoadOp operations for direct variable usage (continuous indicators)</li><li>Identifies ContrastOp operations for categorical variable detection</li><li>Applies type checking to ensure Real element types in the actual data</li><li>Returns sorted list for consistent ordering across calls</li></ul><p>See also: <a href="#FormulaCompiler.derivativeevaluator_fd"><code>derivativeevaluator_fd</code></a>, <a href="#FormulaCompiler.derivativeevaluator_ad"><code>derivativeevaluator_ad</code></a>, <a href="#FormulaCompiler.derivative_modelrow!"><code>derivative_modelrow!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/utilities.jl#L3-L66">source</a></section></article><h3 id="Link-Function-Derivatives"><a class="docs-heading-anchor" href="#Link-Function-Derivatives">Link Function Derivatives</a><a id="Link-Function-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Link-Function-Derivatives" title="Permalink"></a></h3><p>Computational primitives for GLM link function derivatives (used by Margins.jl for computing marginal effects on the mean response).</p><div class="admonition is-warning" id="Missing-docstring.-e4612bd9788d6cbb"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-e4612bd9788d6cbb" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>_dmu_deta</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-ab2a0550d5ff84b2"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-ab2a0550d5ff84b2" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>_d2mu_deta2</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.supported_link_functions" href="#FormulaCompiler.supported_link_functions"><code>FormulaCompiler.supported_link_functions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supported_link_functions() -&gt; Vector{String}</code></pre><p>Return list of GLM link functions with implemented <em>dmu</em>deta methods.</p><p>Note: Link function support is now determined by Julia&#39;s method dispatch. Any link function with a <em>dmu</em>deta method will work automatically. This function provides a convenience list of commonly tested functions.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">links = supported_link_functions()
println(&quot;Common GLM links: &quot;, join(links, &quot;, &quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/contrast_evaluator.jl#L638-L652">source</a></section></article><h2 id="Categorical-Contrasts"><a class="docs-heading-anchor" href="#Categorical-Contrasts">Categorical Contrasts</a><a id="Categorical-Contrasts-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical-Contrasts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.ContrastEvaluator" href="#FormulaCompiler.ContrastEvaluator"><code>FormulaCompiler.ContrastEvaluator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ContrastEvaluator{T, Ops, S, O, NTMerged, CounterfactualTuple}</code></pre><p>Zero-allocation evaluator for categorical and binary variable contrasts.</p><p>Provides efficient discrete marginal effects computation by pre-allocating all buffers and pre-computing categorical level mappings. Eliminates the ~2KB allocation overhead of the basic <code>contrast_modelrow!</code> function for batch contrast operations.</p><p>Uses typed counterfactual vectors for type-stable, zero-allocation performance.</p><p><strong>Fields</strong></p><ul><li><code>compiled</code>: Base compiled formula evaluator</li><li><code>vars</code>: Variables available for contrast computation</li><li><code>data_counterfactual</code>: Counterfactual data structure for variable substitution</li><li><code>counterfactuals</code>: Tuple of typed CounterfactualVector{T} subtypes for each variable</li><li><code>y_from_buf</code>: Pre-allocated buffer for &quot;from&quot; level evaluation</li><li><code>y_to_buf</code>: Pre-allocated buffer for &quot;to&quot; level evaluation</li><li><code>row</code>: Current row being processed</li></ul><p><strong>Performance</strong></p><ul><li><strong>Zero allocations</strong> after construction for all contrast operations</li><li><strong>Type stability</strong> via typed counterfactual vectors</li><li><strong>Buffer reuse</strong> across multiple contrasts and rows</li><li><strong>Type specialization</strong> for compiled formula operations</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs"># One-time setup
evaluator = contrastevaluator(compiled, data, [:treatment, :education])
contrast_buf = Vector{Float64}(undef, length(compiled))

# Fast repeated contrasts (zero allocations)
for row in 1:n_rows
    contrast_modelrow!(contrast_buf, evaluator, row, :treatment, &quot;Control&quot;, &quot;Drug&quot;)
    # Process contrast_buf...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/contrast_evaluator.jl#L3-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.contrastevaluator" href="#FormulaCompiler.contrastevaluator"><code>FormulaCompiler.contrastevaluator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contrastevaluator(compiled, data, vars) -&gt; ContrastEvaluator</code></pre><p>Construct a ContrastEvaluator for efficient categorical and binary contrast computation.</p><p>Pre-allocates all necessary buffers and pre-computes categorical level mappings to eliminate allocations during contrast evaluation.</p><p><strong>Arguments</strong></p><ul><li><code>compiled</code>: Result from <code>compile_formula(model, data)</code></li><li><code>data</code>: Column-table data as NamedTuple</li><li><code>vars</code>: Vector of variable symbols available for contrasts</li></ul><p><strong>Returns</strong></p><p>ContrastEvaluator configured for zero-allocation contrast computation.</p><p><strong>Performance Notes</strong></p><ul><li><strong>One-time cost</strong>: Setup involves building override structures and categorical mappings</li><li><strong>Categorical optimization</strong>: Level mappings computed once, reused for all contrasts</li><li><strong>Memory efficiency</strong>: Buffers sized exactly for the compiled formula</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Setup for categorical contrasts
evaluator = contrastevaluator(compiled, data, [:group, :region, :binary_var])

# Zero-allocation usage
contrast_buf = Vector{Float64}(undef, length(compiled))
contrast_modelrow!(contrast_buf, evaluator, 1, :group, &quot;Control&quot;, &quot;Treatment&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/contrast_evaluator.jl#L67-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.CategoricalLevelMap" href="#FormulaCompiler.CategoricalLevelMap"><code>FormulaCompiler.CategoricalLevelMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CategoricalLevelMap{Var, LevelTuple}</code></pre><p>Stores pre-computed level mappings for a categorical variable in contrast evaluators.</p><p>Similar to <code>ContrastOp</code>, this struct uses type parameters for compile-time specialization while storing runtime level data as a field.</p><p><strong>Type Parameters</strong></p><ul><li><code>Var::Symbol</code>: Variable name (e.g., <code>:group</code>, <code>:treatment</code>)</li><li><code>LevelTuple</code>: Type of the levels tuple (e.g., <code>NTuple{3, Tuple{String, CategoricalValue{UInt32}}}</code>)</li></ul><p><strong>Fields</strong></p><ul><li><code>levels</code>: Tuple of (level, CategoricalValue) pairs preserving natural level types</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># String categorical with 3 levels
CategoricalLevelMap{:group, NTuple{3, Tuple{String, CategoricalValue{UInt32}}}}(
    ((&quot;Control&quot;, catval1), (&quot;Treatment&quot;, catval2), (&quot;Placebo&quot;, catval3))
)

# Integer categorical with 5 levels
CategoricalLevelMap{:age_group, NTuple{5, Tuple{Int64, CategoricalValue{UInt32}}}}(
    ((1, catval1), (2, catval2), (3, catval3), (4, catval4), (5, catval5))
)</code></pre><p><strong>Performance</strong></p><ul><li><strong>Zero allocations</strong>: All types concrete, fully specialized</li><li><strong>Natural types</strong>: No String conversion needed for Int/Symbol levels</li><li><strong>Fast lookup</strong>: Linear search through small tuple (2-10 levels typical)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/types.jl#L292-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.contrast_modelrow!" href="#FormulaCompiler.contrast_modelrow!"><code>FormulaCompiler.contrast_modelrow!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contrast_modelrow!(Δ, evaluator, row, var, from, to) -&gt; Δ</code></pre><p>Compute discrete contrast using pre-allocated ContrastEvaluator (zero allocations).</p><p>Evaluates <code>Δ = X(var=to) - X(var=from)</code> using the evaluator&#39;s pre-allocated buffers and pre-computed categorical mappings for optimal performance.</p><p><strong>Arguments</strong></p><ul><li><code>Δ::AbstractVector{Float64}</code>: Output contrast vector (modified in-place)</li><li><code>evaluator::ContrastEvaluator</code>: Pre-configured contrast evaluator</li><li><code>row::Int</code>: Row index to evaluate</li><li><code>var::Symbol</code>: Variable to contrast (must be in <code>evaluator.vars</code>)</li><li><code>from</code>: Reference level (baseline)</li><li><code>to</code>: Target level (comparison)</li></ul><p><strong>Performance</strong></p><ul><li><strong>Zero allocations</strong> - uses pre-allocated buffers from evaluator</li><li><strong>Categorical optimization</strong> - uses pre-computed level mappings</li><li><strong>Type specialization</strong> - compiled formula operations fully optimized</li></ul><p><strong>Error Handling</strong></p><ul><li>Validates that <code>var</code> exists in evaluator&#39;s variable list</li><li>Handles both categorical and numeric variable types</li><li>Provides clear error messages for invalid level specifications</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">evaluator = contrastevaluator(compiled, data, [:treatment])
contrast_buf = Vector{Float64}(undef, length(compiled))

# Zero-allocation contrast computation
contrast_modelrow!(contrast_buf, evaluator, 1, :treatment, &quot;Control&quot;, &quot;Drug&quot;)
# contrast_buf now contains the discrete effect vector</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/contrast_evaluator.jl#L159-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.contrast_gradient!" href="#FormulaCompiler.contrast_gradient!"><code>FormulaCompiler.contrast_gradient!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contrast_gradient!(∇β, evaluator, row, var, from, to, β, [link]) -&gt; ∇β</code></pre><p>Compute parameter gradients for discrete effects: ∂(discrete_effect)/∂β - zero allocations.</p><p>Computes the gradient of discrete marginal effects with respect to model parameters using the mathematical formula:</p><ul><li><strong>Linear scale (η)</strong>: ∇β = ΔX = X₁ - X₀ (contrast vector)</li><li><strong>Response scale (μ)</strong>: ∇β = g&#39;(η₁) × X₁ - g&#39;(η₀) × X₀ (chain rule with link derivatives)</li></ul><p>This enables uncertainty quantification via the delta method: SE = √(∇β&#39; Σ ∇β).</p><p><strong>Arguments</strong></p><ul><li><code>∇β::AbstractVector{Float64}</code>: Output gradient vector (modified in-place)</li><li><code>evaluator::ContrastEvaluator</code>: Pre-configured contrast evaluator</li><li><code>row::Int</code>: Row index to evaluate</li><li><code>var::Symbol</code>: Variable to contrast (must be in <code>evaluator.vars</code>)</li><li><code>from</code>: Reference level (baseline)</li><li><code>to</code>: Target level (comparison)</li><li><code>β::AbstractVector{&lt;:Real}</code>: Model coefficients (used only for response-scale computation)</li><li><code>link</code>: GLM link function (optional, defaults to linear scale)</li></ul><p><strong>Returns</strong></p><ul><li><code>∇β</code>: The same vector passed in, containing parameter gradients ∂(discrete_effect)/∂β</li></ul><p><strong>Performance</strong></p><ul><li><strong>Zero allocations</strong> - uses pre-allocated buffers from evaluator</li><li><strong>Link function support</strong> - handles all GLM links (Identity, Log, Logit, etc.)</li><li><strong>Type flexibility</strong> - accepts any Real coefficient type, converts internally</li></ul><p><strong>Mathematical Method</strong></p><p><strong>Linear Scale (default)</strong>:</p><pre><code class="language-julia hljs">discrete_effect = η₁ - η₀ = (X₁&#39;β) - (X₀&#39;β) = (X₁ - X₀)&#39;β = ΔX&#39;β
∇β = ΔX = X₁ - X₀</code></pre><p><strong>Response Scale (with link function)</strong>:</p><pre><code class="language-julia hljs">discrete_effect = μ₁ - μ₀ = g⁻¹(η₁) - g⁻¹(η₀)
∇β = g&#39;(η₁) × X₁ - g&#39;(η₀) × X₀  (chain rule)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">evaluator = contrastevaluator(compiled, data, [:treatment])
∇β = Vector{Float64}(undef, length(compiled))

# Linear scale gradients (η = Xβ scale)
contrast_gradient!(∇β, evaluator, 1, :treatment, &quot;Control&quot;, &quot;Drug&quot;, β)

# Response scale gradients (μ = g⁻¹(η) scale)
link = GLM.LogitLink()
contrast_gradient!(∇β, evaluator, 1, :treatment, &quot;Control&quot;, &quot;Drug&quot;, β, link)

# Delta method standard error
se = sqrt(∇β&#39; * vcov_matrix * ∇β)</code></pre><p><strong>Integration with Delta Method</strong></p><p>Parameter gradients enable uncertainty quantification:</p><pre><code class="language-julia hljs"># Compute discrete effect + gradient simultaneously
discrete_effect = contrast_modelrow(evaluator, row, var, from, to)
contrast_gradient!(∇β, evaluator, row, var, from, to, β, link)

# Delta method confidence intervals
variance = ∇β&#39; * vcov_matrix * ∇β
se = sqrt(variance)
ci_lower = discrete_effect - 1.96 * se
ci_upper = discrete_effect + 1.96 * se</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/contrast_evaluator.jl#L410-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.contrast_gradient" href="#FormulaCompiler.contrast_gradient"><code>FormulaCompiler.contrast_gradient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contrast_gradient(evaluator, row, var, from, to, β, [link]) -&gt; Vector{Float64}</code></pre><p>Convenience version that allocates and returns the gradient vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/compilation/contrast_evaluator.jl#L509-L513">source</a></section></article><h2 id="Categorical-Mixtures"><a class="docs-heading-anchor" href="#Categorical-Mixtures">Categorical Mixtures</a><a id="Categorical-Mixtures-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical-Mixtures" title="Permalink"></a></h2><p>Utilities for constructing and validating categorical mixtures used in efficient profile-based marginal effects.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.mix" href="#FormulaCompiler.mix"><code>FormulaCompiler.mix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mix(pairs...)</code></pre><p>Convenient constructor for CategoricalMixture from level =&gt; weight pairs. This is the main user-facing function for creating mixture specifications.</p><p><strong>Arguments</strong></p><ul><li><code>pairs...</code>: Level =&gt; weight pairs (e.g., &quot;A&quot; =&gt; 0.3, &quot;B&quot; =&gt; 0.7)</li></ul><p><strong>Returns</strong></p><ul><li><code>CategoricalMixture</code>: Validated mixture object ready for use with FormulaCompiler</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic categorical mixture
group_mix = mix(&quot;Control&quot; =&gt; 0.4, &quot;Treatment&quot; =&gt; 0.6)

# Educational composition
education_mix = mix(&quot;high_school&quot; =&gt; 0.4, &quot;college&quot; =&gt; 0.4, &quot;graduate&quot; =&gt; 0.2)

# Regional distribution using symbols
region_mix = mix(:urban =&gt; 0.7, :rural =&gt; 0.3)

# Boolean mixture (30% false, 70% true)
treated_mix = mix(false =&gt; 0.3, true =&gt; 0.7)

# Works with any comparable type
age_group_mix = mix(&quot;young&quot; =&gt; 0.25, &quot;middle&quot; =&gt; 0.50, &quot;old&quot; =&gt; 0.25)</code></pre><p><strong>Validation</strong></p><p>The mix() function automatically validates:</p><ul><li>At least one level =&gt; weight pair is provided</li><li>All weights are non-negative</li><li>Weights sum to 1.0 (within numerical tolerance)</li><li>All levels are unique</li></ul><p><strong>Integration with FormulaCompiler</strong></p><p><strong>CounterfactualVector Pattern for Categorical Mixtures</strong></p><p>The unified row-wise architecture provides efficient single-row mixture perturbations:</p><pre><code class="language-julia hljs">using FormulaCompiler, DataFrames, Tables

# Prepare data with mixture column
df = DataFrame(
    y = randn(1000),
    x = randn(1000),
    group = fill(mix(&quot;A&quot; =&gt; 0.4, &quot;B&quot; =&gt; 0.6), 1000)  # Baseline mixture
)
data = Tables.columntable(df)

# Compile formula
model = lm(@formula(y ~ x * group), df)
compiled = compile_formula(model, data)

# Pattern 1: Single-row mixture perturbation
# Create counterfactual vector for mixture column
cf_mixture = counterfactualvector(data.group, 1)  # CategoricalMixtureCounterfactualVector

# Apply different mixture to specific row
new_mixture = mix(&quot;A&quot; =&gt; 0.8, &quot;B&quot; =&gt; 0.2)  # Policy counterfactual
update_counterfactual_row!(cf_mixture, 500)  # Target row 500
update_counterfactual_replacement!(cf_mixture, new_mixture)

# Evaluate with counterfactual data
data_cf = (data..., group=cf_mixture)
output = Vector{Float64}(undef, length(compiled))
compiled(output, data_cf, 500)  # Row 500 uses new mixture, others use baseline

# Pattern 2: Population marginal effects with mixture profiles
function mixture_marginal_effects(model, data, base_mixture, alt_mixture)
    compiled = compile_formula(model, data)
    cf_mixture = counterfactualvector(data.group, 1)
    data_cf = (data..., group=cf_mixture)

    n_rows = length(data.x)
    baseline_effects = Vector{Float64}(undef, n_rows)
    alternative_effects = Vector{Float64}(undef, n_rows)

    for row in 1:n_rows
        update_counterfactual_row!(cf_mixture, row)

        # Baseline mixture
        update_counterfactual_replacement!(cf_mixture, base_mixture)
        compiled(view(baseline_effects, row:row), data_cf, row)

        # Alternative mixture
        update_counterfactual_replacement!(cf_mixture, alt_mixture)
        compiled(view(alternative_effects, row:row), data_cf, row)
    end

    return mean(alternative_effects - baseline_effects)
end

# Example: Policy effect of changing group composition
base_mix = mix(&quot;A&quot; =&gt; 0.4, &quot;B&quot; =&gt; 0.6)
policy_mix = mix(&quot;A&quot; =&gt; 0.7, &quot;B&quot; =&gt; 0.3)
effect = mixture_marginal_effects(model, data, base_mix, policy_mix)</code></pre><p><strong>Reference Grid Pattern</strong></p><p>For systematic marginal effects computation across different mixture profiles:</p><pre><code class="language-julia hljs"># Create reference grid with multiple mixture specifications
mixtures = [
    mix(&quot;A&quot; =&gt; 1.0, &quot;B&quot; =&gt; 0.0),    # Pure A
    mix(&quot;A&quot; =&gt; 0.5, &quot;B&quot; =&gt; 0.5),    # Balanced
    mix(&quot;A&quot; =&gt; 0.0, &quot;B&quot; =&gt; 1.0)     # Pure B
]

# Evaluate effects across all mixture profiles
effects_by_mixture = Vector{Float64}(undef, length(mixtures))
cf_mixture = counterfactualvector(data.group, 1)
data_cf = (data..., group=cf_mixture)

for (i, mixture_spec) in enumerate(mixtures)
    update_counterfactual_replacement!(cf_mixture, mixture_spec)

    # Compute average effect across all rows for this mixture
    row_effects = Vector{Float64}(undef, n_rows)
    for row in 1:n_rows
        update_counterfactual_row!(cf_mixture, row)
        compiled(view(row_effects, row:row), data_cf, row)
    end
    effects_by_mixture[i] = mean(row_effects)
end</code></pre><p><strong>Performance</strong></p><p>Mixture creation is lightweight and validation happens at construction time. The resulting CategoricalMixture objects are compiled into zero-allocation evaluators by FormulaCompiler&#39;s compilation system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/mixtures/constructors.jl#L4-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.CategoricalMixture" href="#FormulaCompiler.CategoricalMixture"><code>FormulaCompiler.CategoricalMixture</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CategoricalMixture{T}</code></pre><p>Represents a mixture of categorical levels with associated weights for statistical analysis. Used to specify population composition scenarios and marginal effects computation.</p><p><strong>Fields</strong></p><ul><li><code>levels::Vector{T}</code>: Categorical levels (strings, symbols, booleans, or other types)</li><li><code>weights::Vector{Float64}</code>: Associated weights (must sum to 1.0)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Educational composition mixture
edu_mix = CategoricalMixture([&quot;high_school&quot;, &quot;college&quot;], [0.6, 0.4])

# Using the convenient mix() constructor
treatment_mix = mix(&quot;control&quot; =&gt; 0.4, &quot;treatment&quot; =&gt; 0.6)
boolean_mix = mix(false =&gt; 0.3, true =&gt; 0.7)</code></pre><p><strong>Validation</strong></p><ul><li>Levels and weights must have the same length</li><li>All weights must be non-negative</li><li>Weights must sum to 1.0 (within tolerance)</li><li>Levels must be unique</li></ul><p><strong>Integration with FormulaCompiler</strong></p><p>CategoricalMixture objects are automatically detected by FormulaCompiler&#39;s compilation system and compiled into efficient zero-allocation evaluators using MixtureContrastOp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/mixtures/types.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.MixtureWithLevels" href="#FormulaCompiler.MixtureWithLevels"><code>FormulaCompiler.MixtureWithLevels</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MixtureWithLevels{T}</code></pre><p>Wrapper that includes original categorical levels with the mixture for FormulaCompiler processing. This type provides proper type-safe access to mixture components for the compilation system.</p><p><strong>Fields</strong></p><ul><li><code>mixture::CategoricalMixture{T}</code>: The core mixture specification</li><li><code>original_levels::Vector{String}</code>: Original levels from the data column</li></ul><p><strong>Usage</strong></p><p>This type is used internally by FormulaCompiler&#39;s scenario system to provide type-safe  mixture processing with access to both mixture specifications and original data structure.</p><pre><code class="language-julia hljs"># Usually created automatically by FormulaCompiler&#39;s scenario system
mixture = mix(&quot;A&quot; =&gt; 0.3, &quot;B&quot; =&gt; 0.7)
original_levels = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]  # From the actual data column
wrapper = MixtureWithLevels(mixture, original_levels)

# Direct property access
wrapper.mixture.levels     # Access to mixture levels
wrapper.mixture.weights    # Access to mixture weights
wrapper.original_levels    # Access to original data levels</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/mixtures/types.jl#L58-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.validate_mixture_against_data" href="#FormulaCompiler.validate_mixture_against_data"><code>FormulaCompiler.validate_mixture_against_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">validate_mixture_against_data(mixture::CategoricalMixture, col, var::Symbol)</code></pre><p>Validate that all levels in the mixture exist in the actual data column. Throws ArgumentError if any mixture levels are not found in the data.</p><p><strong>Arguments</strong></p><ul><li><code>mixture::CategoricalMixture</code>: The mixture specification to validate</li><li><code>col</code>: The data column to validate against</li><li><code>var::Symbol</code>: Variable name for error reporting</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If mixture contains levels not found in the data</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Validate mixture against categorical data
data_col = categorical([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;])
mixture = mix(&quot;A&quot; =&gt; 0.5, &quot;B&quot; =&gt; 0.5)
validate_mixture_against_data(mixture, data_col, :group)  # ✓ Valid

# This would throw an error
bad_mixture = mix(&quot;A&quot; =&gt; 0.5, &quot;X&quot; =&gt; 0.5)  # &quot;X&quot; not in data
validate_mixture_against_data(bad_mixture, data_col, :group)  # ✗ Error</code></pre><p>This function is used internally by FormulaCompiler&#39;s scenario system to ensure mixture specifications are compatible with the actual data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/mixtures/validation.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.mixture_to_scenario_value" href="#FormulaCompiler.mixture_to_scenario_value"><code>FormulaCompiler.mixture_to_scenario_value</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mixture_to_scenario_value(mixture::CategoricalMixture, original_col)</code></pre><p>Convert a categorical mixture to a representative value for FormulaCompiler scenario creation. Uses weighted average encoding to provide a smooth, continuous representation.</p><p><strong>Strategy</strong></p><ul><li><strong>CategoricalArray</strong>: Weighted average of level indices</li><li><strong>Bool</strong>: Probability of true (equivalent to current fractional Bool support)  </li><li><strong>Other</strong>: Weighted average of sorted unique level indices</li></ul><p><strong>Arguments</strong></p><ul><li><code>mixture::CategoricalMixture</code>: The mixture to convert</li><li><code>original_col</code>: The original data column for context</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Continuous representation of the mixture</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Boolean mixture -&gt; probability of true
bool_mix = mix(false =&gt; 0.3, true =&gt; 0.7)
mixture_to_scenario_value(bool_mix, [true, false, true]) # -&gt; 0.7

# Categorical mixture -&gt; weighted average of level indices
cat_mix = mix(&quot;A&quot; =&gt; 0.6, &quot;B&quot; =&gt; 0.4)  
cat_col = categorical([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])
mixture_to_scenario_value(cat_mix, cat_col) # -&gt; 1.4 (0.6*1 + 0.4*2)</code></pre><p>This function is used internally by FormulaCompiler&#39;s scenario system to convert mixture specifications into values that can be used with the existing override system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/mixtures/validation.jl#L104-L136">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FormulaCompiler.not" href="#FormulaCompiler.not"><code>FormulaCompiler.not</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">not(x)</code></pre><p>Logical NOT operation for use in formula specifications.</p><p><strong>Arguments</strong></p><ul><li><code>x::Bool</code>: Returns the logical negation (!x)</li><li><code>x::Real</code>: Returns 1 - x (useful for probability complements)</li></ul><p><strong>Returns</strong></p><ul><li>For Bool: The opposite boolean value</li><li>For Real: The complement (1 - x)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># In a formula
model = lm(@formula(y ~ not(treatment)), df)

# For probabilities
p = 0.3
q = not(p)  # 0.7</code></pre><div class="admonition is-warning" id="Warning-6e7a565810e6fc69"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6e7a565810e6fc69" title="Permalink"></a></header><div class="admonition-body"><p>For Real values, this assumes x is in [0,1] range. No bounds checking is performed.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emfeltham/FormulaCompiler.jl/blob/e546b713daae71ee2a32baea396f5641df9682a3/src/core/utilities.jl#L4-L29">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metaprogramming/">« Metaprogramming</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 17 October 2025 14:00">Friday 17 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
