# phase1_single_term_evaluation.jl - Foundation for Strategy 4

###############################################################################
# Phase 1: Extend EfficientModelMatrices.jl with single-term evaluation
###############################################################################

using StatsModels
using StatsModels: AbstractTerm, Term, ContinuousTerm, CategoricalTerm, ConstantTerm, 
                   InterceptTerm, FunctionTerm, InteractionTerm, MatrixTerm
using CategoricalArrays: refs
using Tables

###############################################################################
# 1.1: Single-Term Evaluation Interface
###############################################################################

"""
    evaluate_term!(term::AbstractTerm, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)

Evaluate a single term independently and write results to output matrix.
This is the core function that enables Strategy 4's column-by-column computation.

# Arguments
- `term`: The specific term to evaluate (e.g., ContinuousTerm(:x), FunctionTerm(log, [:x]))
- `data`: Column-table data (NamedTuple from Tables.columntable)  
- `output`: Pre-allocated matrix to write results (n × width(term))
- `imp`: InplaceModeler for complex term evaluation (may not be needed for simple terms)

# Returns
- `output`: The same matrix, now filled with term evaluation results
"""
function evaluate_term!(term::AbstractTerm, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    # Dispatch to specific term type evaluators
    _evaluate_term_impl!(term, data, output, ipm)
    return output
end

"""
    evaluate_single_column!(term::AbstractTerm, data::NamedTuple, global_col::Int, local_col::Int, output::AbstractVector, ipm::InplaceModeler)

Evaluate a single column of a term and write to output vector.
More efficient than evaluate_term! when you only need one column.

# Arguments  
- `term`: The term that generates the target column
- `data`: Column-table data
- `global_col`: Global column index in full model matrix
- `local_col`: Local column index within this term (1-based)
- `output`: Pre-allocated vector to write results (length n)
- `ipm`: InplaceModeler for complex terms
"""
function evaluate_single_column!(
    term::AbstractTerm, 
    data::NamedTuple, 
    global_col::Int, 
    local_col::Int,
    output::AbstractVector, 
    ipm::InplaceModeler
)
    if width(term) == 1
        # Single-column term - can evaluate directly
        _evaluate_single_column_impl!(term, data, output)
    else
        # Multi-column term - evaluate full term, extract column
        temp_matrix = Matrix{Float64}(undef, length(output), width(term))
        evaluate_term!(term, data, temp_matrix, ipm)
        copy!(output, view(temp_matrix, :, local_col))
    end
    return output
end

###############################################################################
# 1.2: Enhanced ColumnMapping with Term Extraction
###############################################################################

"""
    get_term_for_column(mapping::ColumnMapping, col::Int) -> (AbstractTerm, Int)

Find which term generates a specific global column and the local column index within that term.

# Returns
- `(term, local_col)`: The term and 1-based local column index within the term

# Example
```julia
# For formula: y ~ x + log(x) + x&z
# Column 3 might be generated by FunctionTerm(log, [:x]) at local position 1
term, local_idx = get_term_for_column(mapping, 3)
# Returns: (FunctionTerm(log, [ContinuousTerm(:x)]), 1)
```
"""
function get_term_for_column(mapping::ColumnMapping, col::Int)
    for (term, range) in mapping.term_info
        if col in range
            local_col = col - first(range) + 1
            return (term, local_col)
        end
    end
    error("Column $col not found in mapping")
end

"""
    get_terms_for_columns(mapping::ColumnMapping, cols::Vector{Int}) -> Dict{AbstractTerm, Vector{Tuple{Int,Int}}}

Group columns by the terms that generate them, returning local column indices.

# Returns
- `Dict{AbstractTerm, Vector{Tuple{Int,Int}}}`: Maps terms to [(global_col, local_col), ...]

# Example
```julia
# For columns [2, 3, 5] from formula y ~ x + log(x) + x&z
terms_map = get_terms_for_columns(mapping, [2, 3, 5])
# Returns: Dict(
#   ContinuousTerm(:x) => [(2, 1)],
#   FunctionTerm(log, [:x]) => [(3, 1)], 
#   InteractionTerm([:x, :z]) => [(5, 1)]
# )
```
"""
function get_terms_for_columns(mapping::ColumnMapping, cols::Vector{Int})
    terms_map = Dict{AbstractTerm, Vector{Tuple{Int,Int}}}()
    
    for col in cols
        term, local_col = get_term_for_column(mapping, col)
        
        if !haskey(terms_map, term)
            terms_map[term] = Tuple{Int,Int}[]
        end
        push!(terms_map[term], (col, local_col))
    end
    
    return terms_map
end

"""
    enhanced_column_mapping(model::StatisticalModel) -> ColumnMapping

Create ColumnMapping with validation against existing model matrix.
"""
function enhanced_column_mapping(model::StatisticalModel)
    X_fitted = modelmatrix(model)
    rhs = fixed_effects_form(model).rhs
    mapping = build_column_mapping(rhs)
    
    # Validate mapping matches fitted model
    if mapping.total_columns != size(X_fitted, 2)
        error("Column mapping mismatch: mapping has $(mapping.total_columns) columns, model matrix has $(size(X_fitted, 2)) columns")
    end
    
    return mapping
end

###############################################################################
# 1.3: Single-Term Evaluators (Implementation)
###############################################################################

# ─────────────────────────────────────────────────────────────────────────────
# Simple Terms (Direct Implementation)
# ─────────────────────────────────────────────────────────────────────────────

function _evaluate_term_impl!(term::ContinuousTerm, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    @assert size(output, 2) == 1 "ContinuousTerm produces exactly 1 column"
    copy!(view(output, :, 1), data[term.sym])
    return output
end

function _evaluate_single_column_impl!(term::ContinuousTerm, data::NamedTuple, output::AbstractVector)
    copy!(output, data[term.sym])
    return output
end

function _evaluate_term_impl!(term::ConstantTerm, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    @assert size(output, 2) == 1 "ConstantTerm produces exactly 1 column"
    fill!(view(output, :, 1), term.n)
    return output
end

function _evaluate_single_column_impl!(term::ConstantTerm, data::NamedTuple, output::AbstractVector)
    fill!(output, term.n)
    return output
end

function _evaluate_term_impl!(term::InterceptTerm{true}, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    @assert size(output, 2) == 1 "InterceptTerm produces exactly 1 column"
    fill!(view(output, :, 1), 1.0)
    return output
end

function _evaluate_single_column_impl!(term::InterceptTerm{true}, data::NamedTuple, output::AbstractVector)
    fill!(output, 1.0)
    return output
end

function _evaluate_term_impl!(term::InterceptTerm{false}, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    # No columns produced
    return output
end

function _evaluate_single_column_impl!(term::InterceptTerm{false}, data::NamedTuple, output::AbstractVector)
    fill!(output, 0.0)  # Should not be called, but safe fallback
    return output
end

# Handle untyped Term as ContinuousTerm
function _evaluate_term_impl!(term::Term, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    @assert size(output, 2) == 1 "Term produces exactly 1 column"
    copy!(view(output, :, 1), data[term.sym])
    return output
end

function _evaluate_single_column_impl!(term::Term, data::NamedTuple, output::AbstractVector)
    copy!(output, data[term.sym])
    return output
end

# ─────────────────────────────────────────────────────────────────────────────
# Categorical Terms
# ─────────────────────────────────────────────────────────────────────────────

function _evaluate_term_impl!(term::CategoricalTerm{C,T,N}, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler) where {C,T,N}
    @assert size(output, 2) == N "CategoricalTerm should produce $N columns"
    
    v = data[term.sym]
    codes = refs(v)
    M = term.contrasts.matrix
    rows = length(codes)
    
    @inbounds for r in 1:rows
        @simd for k in 1:N
            output[r, k] = M[codes[r], k]
        end
    end
    
    return output
end

# For categorical terms, single column extraction from full evaluation
function _evaluate_single_column_impl!(term::CategoricalTerm{C,T,N}, data::NamedTuple, output::AbstractVector) where {C,T,N}
    error("_evaluate_single_column_impl! should not be called directly for CategoricalTerm - use evaluate_single_column! instead")
end

# ─────────────────────────────────────────────────────────────────────────────
# Function Terms (Basic Implementation)
# ─────────────────────────────────────────────────────────────────────────────

function _evaluate_term_impl!(term::FunctionTerm, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    @assert size(output, 2) == 1 "FunctionTerm produces exactly 1 column"
    
    nargs = length(term.args)
    n = size(output, 1)
    col = view(output, :, 1)
    
    if nargs == 1
        # Single argument function - optimize common cases
        arg_term = term.args[1]
        if arg_term isa ContinuousTerm
            # Common case: f(x) where x is continuous
            arg_values = data[arg_term.sym]
            @inbounds @simd for i in 1:n
                col[i] = term.f(arg_values[i])
            end
        else
            # More complex argument - evaluate recursively
            arg_buffer = Vector{Float64}(undef, n)
            _evaluate_single_column_impl!(arg_term, data, arg_buffer)
            @inbounds @simd for i in 1:n
                col[i] = term.f(arg_buffer[i])
            end
        end
    elseif nargs == 2
        # Two argument function
        arg1_buffer = Vector{Float64}(undef, n)
        arg2_buffer = Vector{Float64}(undef, n)
        _evaluate_single_column_impl!(term.args[1], data, arg1_buffer)
        _evaluate_single_column_impl!(term.args[2], data, arg2_buffer)
        @inbounds @simd for i in 1:n
            col[i] = term.f(arg1_buffer[i], arg2_buffer[i])
        end
    else
        # General case - use existing InplaceModeler infrastructure
        # This is a fallback for complex nested functions
        _evaluate_term_fallback!(term, data, output, ipm)
    end
    
    return output
end

function _evaluate_single_column_impl!(term::FunctionTerm, data::NamedTuple, output::AbstractVector)
    temp_matrix = Matrix{Float64}(undef, length(output), 1)
    # Use a dummy InplaceModeler - this is not ideal but works for fallback
    _evaluate_term_impl!(term, data, temp_matrix, nothing)
    copy!(output, view(temp_matrix, :, 1))
    return output
end

# ─────────────────────────────────────────────────────────────────────────────
# Complex Terms (Fallback to Full Evaluation)
# ─────────────────────────────────────────────────────────────────────────────

function _evaluate_term_impl!(term::InteractionTerm, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    # Fallback to existing _cols! infrastructure for now
    # TODO: Implement native interaction evaluation
    _evaluate_term_fallback!(term, data, output, imp)
    return output
end

function _evaluate_term_impl!(term::MatrixTerm, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    # Evaluate each sub-term and concatenate
    col_offset = 0
    for subterm in term.terms
        subterm_width = width(subterm)
        if subterm_width > 0
            subterm_output = view(output, :, col_offset+1:col_offset+subterm_width)
            _evaluate_term_impl!(subterm, data, subterm_output, ipm)
            col_offset += subterm_width
        end
    end
    return output
end

function _evaluate_term_fallback!(term::AbstractTerm, data::NamedTuple, output::AbstractMatrix, ipm::InplaceModeler)
    # Fallback: use existing _cols! infrastructure
    # This requires constructing a minimal evaluation context
    if ipm === nothing
        error("InplaceModeler required for complex term evaluation: $(typeof(term))")
    end
    
    # Reset counters and use existing _cols! system
    fn_i = Ref(1)
    int_i = Ref(1)
    _cols!(term, data, output, 1, ipm, fn_i, int_i)
    
    return output
end

###############################################################################
# 1.4: Validation and Testing Infrastructure
###############################################################################

"""
    validate_single_term_evaluation(model::StatisticalModel, data::NamedTuple) -> Bool

Validate that single-term evaluation produces the same results as full model matrix construction.
"""
function validate_single_term_evaluation(model::StatisticalModel, data::NamedTuple)
    # Get full model matrix using existing system
    n = length(first(data))
    p = width(fixed_effects_form(model).rhs)
    ipm = InplaceModeler(model, n)
    X_full = Matrix{Float64}(undef, n, p)
    modelmatrix!(ipm, data, X_full)
    
    # Get column mapping
    mapping = enhanced_column_mapping(model)
    
    # Validate each column using single-term evaluation
    all_match = true
    for col in 1:p
        term, local_col = get_term_for_column(mapping, col)
        
        # Evaluate single column
        col_result = Vector{Float64}(undef, n)
        try
            evaluate_single_column!(term, data, col, local_col, col_result, ipm)
            
            # Compare with full matrix column
            full_col = X_full[:, col]
            max_diff = maximum(abs.(col_result .- full_col))
            
            if max_diff > 1e-12
                @warn "Column $col mismatch: max difference = $max_diff" term
                all_match = false
            end
        catch e
            @warn "Failed to evaluate column $col" term exception=e
            all_match = false
        end
    end
    
    return all_match
end

"""
    test_single_term_evaluation()

Test single-term evaluation on various term types.
"""
function test_single_term_evaluation()
    using DataFrames, StatsModels, GLM
    
    println("Testing single-term evaluation...")
    
    # Create test data
    n = 100
    df = DataFrame(
        x = randn(n),
        z = randn(n),
        w = randn(n),
        group = rand(["A", "B", "C"], n),
        y = randn(n)
    )
    
    # Test various formulas
    formulas = [
        @formula(y ~ x),                           # Simple continuous
        @formula(y ~ 1 + x),                      # Intercept + continuous  
        @formula(y ~ x + z),                      # Multiple continuous
        @formula(y ~ x + C(group)),               # Continuous + categorical
        @formula(y ~ x + z + C(group)),           # Mixed terms
        @formula(y ~ log(x) + sqrt(abs(z))),      # Function terms
        @formula(y ~ x + x^2),                    # Polynomial
        @formula(y ~ x & z),                      # Simple interaction
    ]
    
    for (i, formula) in enumerate(formulas)
        println("Testing formula $i: $formula")
        
        try
            # Fit model
            model = lm(formula, df)
            data = Tables.columntable(df)
            
            # Validate single-term evaluation
            is_valid = validate_single_term_evaluation(model, data)
            
            if is_valid
                println("  ✓ PASSED")
            else
                println("  ✗ FAILED")
            end
        catch e
            println("  ✗ ERROR: $e")
        end
    end
    
    println("Single-term evaluation testing complete.")
end

# Export new functions
export evaluate_term!, evaluate_single_column!
export get_term_for_column, get_terms_for_columns, enhanced_column_mapping
export validate_single_term_evaluation, test_single_term_evaluation